# Phase 25 â€” UI Inference Audit (Scoped)

Scanned roots:
- public
- ui

Goal:
- Find lifecycle inference
- Find row-id / DOM-id misuse as task_id
- Find optimistic UI patterns
- Find SSE disconnect handling that implies lifecycle changes

Findings:
- 
- ## 1) Lifecycle-ish keywords
- public/dashboard-tabs.js:42:  if (e.event.startsWith("completed-task")) div.classList.add("complete");
- public/dashboard-tabs.js:85:    alert(`${agent} ${action} failed: ${err.message}`);
- public/dashboard.backup.js:76:    console.error("âŒ Chat fetch failed:", err);
- public/dashboard.html.bad_structure:186:    console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:270:    console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:287:    console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:302:    console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:317:    console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:334:    console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:415:        console.error("Matilda fetch failed:", err);
- public/dashboard.html.bad_structure:432:    console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:447:    console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:464:    console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:480:    console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:504:        console.error("Delegation failed:", data);
- public/dashboard.html.bad_structure:505:        alert("Delegation failed. Check the terminal logs for details.");
- public/dashboard.html.bad_structure:509:      alert("Delegation failed â€” see console for details.");
- public/dashboard.html.bad_structure:534:      console.error("Delegation failed:", err);
- public/dashboard.html.bad_structure:555:        console.error("Delegation failed payload:", data);
- public/dashboard.html.bad_structure:556:        alert("Delegation failed. Check console/logs.");
- public/dashboard.html.bad_structure:560:      alert("Delegation failed â€” see console for details.");
- public/dashboard.html.bad_structure:586:        console.error("Delegation failed payload:", data);
- public/dashboard.html.bad_structure:587:        alert("Delegation failed. Check console/logs.");
- public/dashboard.html.bad_structure:591:      alert("Delegation failed â€” see console for details.");
- public/dashboard.html.bak.1762372376:215:        console.error("Matilda fetch failed:", err);
- public/dashboard.html.bak.1762457360:329:        console.error("Matilda fetch failed:", err);
- public/js/phase23_matilda_delegate_taskspec.js:22:      try { fn(`ðŸ“¨ delegated â†’ task.queued [${tid}]`); } catch (_) {}
- public/js/task-completion.js:29:                messageDisplay.textContent = `Failure: ${data.message || 'Task completion failed.'}`;
- public/js/task-completion.js:33:            console.error('Task completion API call failed:', error);
- public/js/task-completion.js:35:            messageDisplay.textContent = 'Completion failed due to network error.';
- public/tmp/reflections.json:209:    "content": "ðŸ¤– Cade completed a delegation task successfully.",
- public/tmp/reflections.json:214:    "content": "ðŸ¤– Cade completed a delegation task successfully.",
- public/dashboard-tabs.backup.js:41:  if (e.event.startsWith("completed-task")) div.classList.add("complete");
- public/dashboard-tabs.backup.js:83:    alert(`${agent} ${action} failed: ${err.message}`);
- public/js/task-events-sse-client.js:69:    counts.textContent = "created:0  completed:0  failed:0";
- public/js/task-events-sse-client.js:130:  const tally = { created: 0, completed: 0, failed: 0 };
- public/js/task-events-sse-client.js:133:    if (kind === "task.created") tally.created += 1;
- public/js/task-events-sse-client.js:134:    if (kind === "task.completed") tally.completed += 1;
- public/js/task-events-sse-client.js:135:    if (kind === "task.failed") tally.failed += 1;
- public/js/task-events-sse-client.js:138:    if (el) el.textContent = `created:${tally.created}  completed:${tally.completed}  failed:${tally.failed}`;
- public/js/task-events-sse-client.js:171:    if (kind === "task.completed") row.style.borderColor = "rgba(80,200,120,0.35)";
- public/js/task-events-sse-client.js:172:    if (kind === "task.failed") row.style.borderColor = "rgba(240,90,90,0.35)";
- public/js/task-events-sse-client.js:197:      // server sends event: task.event with payload { type:"task.created|task.completed|task.failed", taskId:"..." }
- public/js/task-events-sse-client.js:211:    if (ev.kind === "task.created" || ev.kind === "task.completed" || ev.kind === "task.failed") {
- public/js/task-events-sse-client.js:258:      "task.created",
- public/js/task-events-sse-client.js:259:      "task.completed",
- public/js/task-events-sse-client.js:260:      "task.failed",
- public/js/phase22_task_delegation_live_bindings.js:9:    done: "task-status-done",
- public/js/phase22_task_delegation_live_bindings.js:10:    failed: "task-status-failed",
- public/js/phase22_task_delegation_live_bindings.js:16:    if (v === "done" || v === "complete" || v === "completed") return "done";
- public/js/phase22_task_delegation_live_bindings.js:17:    if (v === "failed" || v === "error") return "failed";
- public/js/phase22_task_delegation_live_bindings.js:32:      (ev?.kind === "task.created" ? "queued" : null);
- public/js/phase22_task_delegation_live_bindings.js:73:    let queued = 0, done = 0, failed = 0;
- public/js/phase22_task_delegation_live_bindings.js:77:      else if (s === "done") done++;
- public/js/phase22_task_delegation_live_bindings.js:78:      else if (s === "failed") failed++;
- public/js/phase22_task_delegation_live_bindings.js:83:      ["done", done],
- public/js/phase22_task_delegation_live_bindings.js:84:      ["failed", failed],
- public/js/phase22_task_delegation_live_bindings.js:110:      if (ev.kind === "task.completed") t.status = "done";
- public/js/phase22_task_delegation_live_bindings.js:111:      if (ev.kind === "task.failed") t.status = "failed";
- public/dashboard.html.bak:186:    console.error("Delegation failed:", err);
- public/dashboard.html.bak:270:    console.error("Delegation failed:", err);
- public/dashboard.html.bak:287:    console.error("Delegation failed:", err);
- public/dashboard.html.bak:302:    console.error("Delegation failed:", err);
- public/dashboard.html.bak:317:    console.error("Delegation failed:", err);
- public/dashboard.html.bak:334:    console.error("Delegation failed:", err);
- public/dashboard.html.bak:415:        console.error("Matilda fetch failed:", err);
- public/dashboard.html.bak:432:    console.error("Delegation failed:", err);
- public/dashboard.html.bak:447:    console.error("Delegation failed:", err);
- public/dashboard.html.bak:464:    console.error("Delegation failed:", err);
- public/dashboard.html.bak:480:    console.error("Delegation failed:", err);
- public/dashboard.html.bak:504:        console.error("Delegation failed:", data);
- public/dashboard.html.bak:505:        alert("Delegation failed. Check the terminal logs for details.");
- public/dashboard.html.bak:509:      alert("Delegation failed â€” see console for details.");
- public/dashboard.html.bak:534:      console.error("Delegation failed:", err);
- public/dashboard.html.bak:555:        console.error("Delegation failed payload:", data);
- public/dashboard.html.bak:556:        alert("Delegation failed. Check console/logs.");
- public/dashboard.html.bak:560:      alert("Delegation failed â€” see console for details.");
- public/dashboard.html.bak:586:        console.error("Delegation failed payload:", data);
- public/dashboard.html.bak:587:        alert("Delegation failed. Check console/logs.");
- public/dashboard.html.bak:591:      alert("Delegation failed â€” see console for details.");
- public/js/agent-status-row.js:67:    if (s.includes("error") || s.includes("failed") || s.includes("offline")) {
- public/js/task-events-sse-listener.js:197:      "task.created",
- public/js/task-events-sse-listener.js:199:      "task.completed",
- public/js/task-events-sse-listener.js:200:      "task.failed",
- public/bundle-core.js:41:      if (s.includes("error") || s.includes("failed") || s.includes("critical")) {
- public/bundle-core.js:106:      if (statusLower.includes("success") || statusLower.includes("completed") || statusLower.includes("ok")) {
- public/bundle-core.js:108:      } else if (statusLower.includes("error") || statusLower.includes("failed")) {
- public/bundle-core.js:14661:    const completedData = tasks.map((t) => t.status === "completed" ? 1 : 0);
- public/bundle-core.js:14662:    const failedData = tasks.map((t) => t.status === "failed" ? 1 : 0);
- public/js/dashboard-tasks-widget.js:55:    if (!res.ok) throw new Error(json?.error || "Request failed");
- public/js/dashboard-tasks-widget.js:108:                (["complete","completed","done"].includes(String(t.status||"").toLowerCase()))
- public/js/task-activity-graph.js:13:    const completedData = tasks.map(t => t.status === "completed" ? 1 : 0);
- public/js/task-activity-graph.js:14:    const failedData = tasks.map(t => t.status === "failed" ? 1 : 0);
- public/dashboard-logs.v3.js:18:      console.error(`âŒ Fetch failed for ${endpoint}:`, err);
- public/bundle.js.map:4:  "sourcesContent": ["/**\n * Phase 16 \u2013 Shared Heartbeat Bus (OPS + Tasks)\n *\n * Wrap EventSource so connection + any SSE message updates a normalized heartbeat store.\n *\n * Exposes:\n *   window.__HB = { record(kind, ts), get(kind), snapshot() }\n *\n * kind: \"ops\" | \"tasks\" | \"reflections\" | \"unknown\"\n */\n(function () {\n  const w = window;\n\n  const STORE_KEY = \"__HB\";\n  if (!w[STORE_KEY]) {\n    const state = { ops: null, tasks: null, reflections: null, unknown: null };\n    w[STORE_KEY] = {\n      record(kind, ts) {\n        const k = Object.prototype.hasOwnProperty.call(state, kind) ? kind : \"unknown\";\n        state[k] = typeof ts === \"number\" ? ts : Date.now();\n        return state[k];\n      },\n      get(kind) {\n        const k = Object.prototype.hasOwnProperty.call(state, kind) ? kind : \"unknown\";\n        return state[k];\n      },\n      snapshot() {\n        return { ...state };\n      },\n    };\n  }\n\n  const NativeEventSource = w.EventSource;\n  if (!NativeEventSource || NativeEventSource.__hbWrapped) return;\n\n  function classify(url) {\n    const u = String(url || \"\");\n    if (u.includes(\"/events/ops\")) return \"ops\";\n    if (u.includes(\"/events/tasks\")) return \"tasks\";\n    if (u.includes(\"/events/reflections\")) return \"reflections\";\n    return \"unknown\";\n  }\n\n  function HeartbeatEventSource(url, eventSourceInitDict) {\n    const kind = classify(url);\n\n    // Record immediately on connection attempt so \"connected but quiet\" still looks alive.\n    try { w[STORE_KEY].record(kind, Date.now()); } catch (_) {}\n\n    const es = new NativeEventSource(url, eventSourceInitDict);\n\n    const update = () => {\n      try { w[STORE_KEY].record(kind, Date.now()); } catch (_) {}\n    };\n\n    // Update heartbeat when the connection opens (most reliable for \"alive\").\n    try { es.addEventListener(\"open\", update); } catch (_) {}\n\n    // Update heartbeat on any message for this stream.\n    try { es.addEventListener(\"message\", update); } catch (_) {}\n\n    // Also wrap onmessage if assigned later.\n    let _onmessage = null;\n    Object.defineProperty(es, \"onmessage\", {\n      get() { return _onmessage; },\n      set(fn) {\n        _onmessage = function (ev) {\n          update();\n          if (typeof fn === \"function\") return fn.call(es, ev);\n        };\n      },\n      configurable: true,\n    });\n\n    // Update heartbeat when errors occur too (helps show \"something happened\" vs silence).\n    try { es.addEventListener(\"error\", update); } catch (_) {}\n\n    return es;\n  }\n\n  HeartbeatEventSource.prototype = NativeEventSource.prototype;\n  HeartbeatEventSource.__hbWrapped = true;\n\n  w.EventSource = HeartbeatEventSource;\n})();\n", "/**\n * Phase 16 \u2013 Heartbeat stale-state indicator (non-intrusive)\n *\n * Reads window.__HB (from sse-heartbeat-shim) and updates a tiny badge.\n * - Adds a badge to the top-right corner of the dashboard.\n * - Shows OK when both OPS+Tasks have recent heartbeats.\n * - Shows STALE when either stream is missing or old.\n *\n * No coupling to widget internals. Safe to remove.\n */\n(function () {\n  const w = window;\n  const HB = w.__HB;\n\n  function now() {\n    return Date.now();\n  }\n\n  function ms(n) {\n    return Math.max(0, Number(n) || 0);\n  }\n\n  // Consider heartbeats stale after this many ms.\n  const STALE_MS = 15000;\n\n  function fmtAge(ts) {\n    if (!ts) return \"\u2014\";\n    const s = Math.floor((now() - ts) / 1000);\n    return s <= 0 ? \"0s\" : `${s}s`;\n  }\n\n  function ensureBadge() {\n    let el = document.getElementById(\"hb-badge\");\n    if (el) return el;\n\n    el = document.createElement(\"div\");\n    el.id = \"hb-badge\";\n    el.setAttribute(\"role\", \"status\");\n    el.style.position = \"fixed\";\n    el.style.top = \"12px\";\n    el.style.right = \"12px\";\n    el.style.zIndex = \"9999\";\n    el.style.fontFamily = \"ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial\";\n    el.style.fontSize = \"12px\";\n    el.style.padding = \"6px 10px\";\n    el.style.borderRadius = \"999px\";\n    el.style.border = \"1px solid rgba(255,255,255,0.14)\";\n    el.style.background = \"rgba(0,0,0,0.55)\";\n    el.style.backdropFilter = \"blur(6px)\";\n    el.style.webkitBackdropFilter = \"blur(6px)\";\n    el.style.color = \"rgba(255,255,255,0.92)\";\n    el.style.boxShadow = \"0 8px 18px rgba(0,0,0,0.35)\";\n    el.style.userSelect = \"none\";\n    el.style.cursor = \"default\";\n    document.body.appendChild(el);\n    return el;\n  }\n\n  function setState(el, ok) {\n    // No colors specified by instruction in other contexts; keep neutral text-only signal.\n    // We\u2019ll use symbols instead of colored fills.\n    el.textContent = ok\n      ? `HB \u2713 (ops ${fmtAge(HB && HB.get(\"ops\"))}, tasks ${fmtAge(HB && HB.get(\"tasks\"))})`\n      : `HB ! (ops ${fmtAge(HB && HB.get(\"ops\"))}, tasks ${fmtAge(HB && HB.get(\"tasks\"))})`;\n  }\n\n  function tick() {\n    const el = ensureBadge();\n\n    if (!HB || typeof HB.get !== \"function\") {\n      el.textContent = \"HB ? (shim not loaded)\";\n      return;\n    }\n\n    const ops = HB.get(\"ops\");\n    const tasks = HB.get(\"tasks\");\n\n    const opsOk = !!ops && ms(now() - ops) <= STALE_MS;\n    const tasksOk = !!tasks && ms(now() - tasks) <= STALE_MS;\n\n    setState(el, opsOk && tasksOk);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      tick();\n      setInterval(tick, 1000);\n    });\n  } else {\n    tick();\n    setInterval(tick, 1000);\n  }\n})();\n", "/**\n * Phase 21: Task Events SSE listener\n * - Parallel to ops/reflections (does not modify their ownership)\n * - Opens EventSource(\"/events/task-events\")\n * - Buffers events on window.__TASK_EVENTS_FEED and emits DOM event \"task-events:append\"\n * - Tiny debug panel is ALWAYS clickable (collapsed by default)\n *   - Auto-expands when window.__UI_DEBUG or window.__PHASE21_SHOW_TASK_EVENTS is true\n * - Exposes window.__TASK_EVENTS snapshot for quick inspection\n */\n(function () {\n  const URL = \"/events/task-events\";\n  const MAX_ITEMS = 200;\n\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") return;\n  if (window.__TASK_EVENTS_SSE_INITED) return;\n  window.__TASK_EVENTS_SSE_INITED = true;\n\n  function nowIso() {\n    try { return new Date().toISOString(); } catch { return String(Date.now()); }\n  }\n\n  function ensureBuffer() {\n    if (!window.__TASK_EVENTS_FEED) window.__TASK_EVENTS_FEED = [];\n    return window.__TASK_EVENTS_FEED;\n  }\n\n  function ensureSnapshot() {\n    if (!window.__TASK_EVENTS) {\n      window.__TASK_EVENTS = {\n        url: URL,\n        connected: false,\n        lastAt: 0,\n        lastEvent: null,\n        cursor: null,\n        readyState: null,\n      };\n    }\n    return window.__TASK_EVENTS;\n  }\n\n  function pushItem(item) {\n    const buf = ensureBuffer();\n    buf.push(item);\n    if (buf.length > MAX_ITEMS) buf.splice(0, buf.length - MAX_ITEMS);\n\n    const snap = ensureSnapshot();\n    snap.lastAt = item.ts || Date.now();\n    snap.lastEvent = item.event || item.kind || null;\n    if (item?.data && typeof item.data === \"object\" && \"cursor\" in item.data) {\n      snap.cursor = item.data.cursor ?? snap.cursor;\n    }\n    try { snap.readyState = window.__taskEventsES?.readyState ?? null; } catch {}\n\n    try {\n      window.dispatchEvent(new CustomEvent(\"task-events:append\", { detail: item }));\n    } catch {}\n  }\n\n  function safeJson(s) {\n    try { return JSON.parse(s); } catch { return null; }\n  }\n\n  function ensureMiniPanel() {\n    if (document.getElementById(\"task-events-log\")) return;\n\n    const wrap = document.createElement(\"div\");\n    wrap.id = \"task-events-log\";\n    wrap.style.position = \"fixed\";\n    wrap.style.right = \"14px\";\n    wrap.style.bottom = \"14px\";\n    wrap.style.width = \"440px\";\n    wrap.style.maxHeight = \"240px\";\n    wrap.style.overflow = \"hidden\"; // body scrolls, header stays\n    wrap.style.padding = \"10px 12px\";\n    wrap.style.borderRadius = \"12px\";\n    wrap.style.fontFamily = \"ui-monospace, Menlo, Monaco, Consolas, monospace\";\n    wrap.style.fontSize = \"12px\";\n    wrap.style.lineHeight = \"1.35\";\n    wrap.style.zIndex = \"99999\";\n    wrap.style.background = \"rgba(10,10,14,0.72)\";\n    wrap.style.border = \"1px solid rgba(255,255,255,0.12)\";\n    wrap.style.boxShadow = \"0 10px 24px rgba(0,0,0,0.35)\";\n    wrap.style.backdropFilter = \"blur(6px)\";\n    wrap.style.display = \"block\"; // ALWAYS clickable\n\n    const hdr = document.createElement(\"div\");\n    hdr.style.display = \"flex\";\n    hdr.style.alignItems = \"center\";\n    hdr.style.justifyContent = \"space-between\";\n    hdr.style.gap = \"10px\";\n    hdr.style.marginBottom = \"8px\";\n\n    const title = document.createElement(\"div\");\n    title.id = \"task-events-log-title\";\n    title.textContent = \"TASK EVENTS \u00B7 disconnected\";\n    title.style.letterSpacing = \"0.12em\";\n    title.style.fontWeight = \"700\";\n    title.style.opacity = \"0.9\";\n\n    const btn = document.createElement(\"button\");\n    btn.type = \"button\";\n    btn.textContent = \"expand\";\n    btn.style.cursor = \"pointer\";\n    btn.style.border = \"1px solid rgba(255,255,255,0.15)\";\n    btn.style.background = \"rgba(255,255,255,0.08)\";\n    btn.style.color = \"rgba(255,255,255,0.9)\";\n    btn.style.borderRadius = \"10px\";\n    btn.style.padding = \"4px 8px\";\n    btn.style.fontSize = \"12px\";\n\n    const body = document.createElement(\"div\");\n    body.id = \"task-events-log-body\";\n    body.style.maxHeight = \"190px\";\n    body.style.overflow = \"auto\";\n    body.style.display = \"none\"; // collapsed by default\n\n    btn.onclick = () => {\n      const on = body.style.display === \"none\";\n      body.style.display = on ? \"block\" : \"none\";\n      btn.textContent = on ? \"collapse\" : \"expand\";\n    };\n\n    hdr.appendChild(title);\n    hdr.appendChild(btn);\n\n    wrap.appendChild(hdr);\n    wrap.appendChild(body);\n    document.body.appendChild(wrap);\n\n    // Auto-expand when debugging\n    if (window.__UI_DEBUG || window.__PHASE21_SHOW_TASK_EVENTS) {\n      body.style.display = \"block\";\n      btn.textContent = \"collapse\";\n    }\n  }\n\n  function appendLine(text) {\n    const body = document.getElementById(\"task-events-log-body\");\n    if (!body) return;\n    const div = document.createElement(\"div\");\n    div.style.whiteSpace = \"pre-wrap\";\n    div.style.wordBreak = \"break-word\";\n    div.textContent = text;\n    body.appendChild(div);\n    while (body.childNodes.length > 140) body.removeChild(body.firstChild);\n    body.scrollTop = body.scrollHeight;\n  }\n\n  function setHeaderStatus(text) {\n    const t = document.getElementById(\"task-events-log-title\");\n    if (t) t.textContent = text;\n  }\n\n  function start() {\n    ensureMiniPanel();\n    ensureSnapshot();\n\n    const es = new EventSource(URL);\n    window.__taskEventsES = es;\n\n    es.onopen = () => {\n      const snap = ensureSnapshot();\n      snap.connected = true;\n      snap.readyState = es.readyState;\n\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"sse.open\", event: \"open\", url: URL };\n      pushItem(item);\n      setHeaderStatus(\"TASK EVENTS \u00B7 connected\");\n      appendLine(`[${item.iso}] open ${URL}`);\n    };\n\n    es.onerror = () => {\n      const snap = ensureSnapshot();\n      snap.connected = false;\n      snap.readyState = es.readyState;\n\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"sse.error\", event: \"error\", url: URL, readyState: es.readyState };\n      pushItem(item);\n      setHeaderStatus(`TASK EVENTS \u00B7 error (readyState=${es.readyState})`);\n      appendLine(`[${item.iso}] error readyState=${es.readyState}`);\n    };\n\n    // default \"message\"\n    es.onmessage = (ev) => {\n      const payload = safeJson(ev.data);\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"message\", event: \"message\", data: payload ?? ev.data };\n      pushItem(item);\n      appendLine(`[${item.iso}] message :: ${payload ? JSON.stringify(payload) : String(ev.data)}`);\n    };\n\n    // named events (include what server ACTUALLY emits: task.event)\n    const names = [\n      \"hello\",\n      \"heartbeat\",\n      \"task.event\",\n      \"task.lifecycle\",\n      \"task.created\",\n      \"task.updated\",\n      \"task.completed\",\n      \"task.failed\",\n      \"error\",\n    ];\n\n    for (const name of names) {\n      try {\n        es.addEventListener(name, (ev) => {\n          const payload = safeJson(ev.data);\n          const item = { ts: Date.now(), iso: nowIso(), kind: \"event\", event: name, data: payload ?? ev.data };\n          pushItem(item);\n          appendLine(`[${item.iso}] ${name} :: ${payload ? JSON.stringify(payload) : String(ev.data)}`);\n        });\n      } catch {}\n    }\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", start, { once: true });\n  } else {\n    start();\n  }\n})();\n", "/**\n * Phase 16: Dashboard wiring for OPS + Reflections SSE streams.\n *\n * - Consume /events/ops + /events/reflections via EventSource\n * - Treat *.state as \"initial paint\" (replace baseline state)\n * - Treat subsequent events as incremental updates (merge / patch)\n * - Add tiny \u201Cconnected / last event\u201D UI indicator for each stream\n *\n * NOTE: Your SSE server emits NAMED events (e.g. \"ops.state\", \"reflections.state\").\n * EventSource.onmessage only receives UNNAMED events, so we must addEventListener()\n * for the named event types we care about.\n */\n\n(() => {\n  \"use strict\";\n\n  const OPS_SSE_URL = \"/events/ops\";\n  const REFLECTIONS_SSE_URL = \"/events/reflections\";\n\n  const NOW = () => Date.now();\n\n  function safeJsonParse(s) {\n    try { return JSON.parse(s); } catch { return null; }\n  }\n\n  function formatAge(ms) {\n    if (!Number.isFinite(ms)) return \"\u2014\";\n    const s = Math.floor(ms / 1000);\n    if (s < 60) return `${s}s`;\n    const m = Math.floor(s / 60);\n    if (m < 60) return `${m}m`;\n    return `${Math.floor(m / 60)}h`;\n  }\n\n  function el(tag, attrs = {}, text = \"\") {\n    const n = document.createElement(tag);\n    for (const [k, v] of Object.entries(attrs)) {\n      if (k === \"class\") n.className = v;\n      else if (k === \"style\") n.setAttribute(\"style\", v);\n      else n.setAttribute(k, v);\n    }\n    if (text) n.textContent = text;\n    return n;\n  }\n\n  function ensureStyles() {\n    if (document.getElementById(\"phase16-sse-style\")) return;\n    const s = el(\"style\", { id: \"phase16-sse-style\" });\n    s.textContent = `\n      .sse-indicator {\n        display:inline-flex;\n        align-items:center;\n        gap:6px;\n        font-size:11px;\n        line-height:1;\n        opacity:.85;\n        user-select:none;\n        white-space:nowrap;\n      }\n      .sse-indicator .dot {\n        width:7px; height:7px; border-radius:999px;\n        background:#555;\n        box-shadow:0 0 0 1px rgba(255,255,255,.08) inset;\n      }\n      .sse-indicator[data-connected=\"true\"] .dot { background:#2dd4bf; }\n      .sse-indicator[data-connected=\"false\"] .dot { background:#f97316; }\n      .sse-indicator .meta { font-variant-numeric: tabular-nums; }\n    `;\n    document.head.appendChild(s);\n  }\n\n  function mount(anchor, id, label) {\n    ensureStyles();\n\n    if (!anchor) {\n      let tray = document.getElementById(\"phase16-sse-tray\");\n      if (!tray) {\n        tray = el(\"div\", {\n          id: \"phase16-sse-tray\",\n          style: [\n            \"position:fixed\",\n            \"left:10px\",\n            \"bottom:10px\",\n            \"display:flex\",\n            \"flex-direction:column\",\n            \"gap:6px\",\n            \"z-index:9999\",\n            \"pointer-events:none\",\n          ].join(\";\")\n        });\n        document.body.appendChild(tray);\n      }\n      anchor = tray;\n    }\n\n    let node = document.getElementById(id);\n    if (node) return node;\n\n    node = el(\"span\", { id, class: \"sse-indicator\", \"data-connected\": \"false\" });\n    node.append(\n      el(\"span\", { class: \"dot\", \"aria-hidden\": \"true\" }),\n      el(\"span\", { class: \"meta\" }, `${label}: disconnected \u00B7 last: \u2014`)\n    );\n\n    // try to place nicely; otherwise append\n    try {\n      if (anchor.matches && anchor.matches(\"header,h1,h2,h3,h4,strong\")) {\n        const wrap = el(\"span\", { style: \"margin-left:8px\" });\n        wrap.appendChild(node);\n        anchor.appendChild(wrap);\n      } else {\n        const wrap = el(\"div\", { style: \"margin-top:4px\" });\n        wrap.appendChild(node);\n        anchor.appendChild(wrap);\n      }\n    } catch {\n      anchor.appendChild(node);\n    }\n\n    return node;\n  }\n\n  function set(ind, label, connected, lastAt) {\n    if (!ind) return;\n    ind.dataset.connected = connected ? \"true\" : \"false\";\n    const meta = ind.querySelector(\".meta\");\n    if (!meta) return;\n    meta.textContent = `${label}: ${connected ? \"connected\" : \"disconnected\"} \u00B7 last: ${lastAt ? formatAge(NOW() - lastAt) : \"\u2014\"}`;\n  }\n\n  function ensureGlobal() {\n    window.__MB_STREAMS ||= {\n      ops: { connected: false, lastAt: 0, state: {}, es: null },\n      reflections: { connected: false, lastAt: 0, state: {}, es: null },\n    };\n    return window.__MB_STREAMS;\n  }\n\n  function shallowMerge(target, patch) {\n    if (!target || typeof target !== \"object\") target = {};\n    if (!patch || typeof patch !== \"object\") return target;\n    return Object.assign(target, patch);\n  }\n\n  // Minimal dot-path patch support: { path:\"a.b.c\", value:any }\n  function applyDotPathPatch(state, patch) {\n    if (!state || typeof state !== \"object\") state = {};\n    const path = patch && typeof patch.path === \"string\" ? patch.path : \"\";\n    if (!path) return state;\n    const parts = path.split(\".\").filter(Boolean);\n    if (!parts.length) return state;\n    let cur = state;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const k = parts[i];\n      if (!cur[k] || typeof cur[k] !== \"object\") cur[k] = {};\n      cur = cur[k];\n    }\n    cur[parts[parts.length - 1]] = patch.value;\n    return state;\n  }\n\n  function isStateEvent(evtType, parsed) {\n    if (typeof evtType === \"string\" && evtType.endsWith(\".state\")) return true;\n    if (parsed && typeof parsed === \"object\") {\n      if (parsed.state && typeof parsed.state === \"object\") return true;\n      if (typeof parsed.type === \"string\" && parsed.type.includes(\"state\")) return true;\n      if (typeof parsed.event === \"string\" && parsed.event.includes(\"state\")) return true;\n    }\n    return false;\n  }\n\n  function extractPayload(parsed) {\n    if (!parsed || typeof parsed !== \"object\") return parsed;\n    if (parsed.payload !== undefined) return parsed.payload;\n    if (parsed.data !== undefined) return parsed.data;\n    if (parsed.delta !== undefined) return parsed.delta;\n    if (parsed.patch !== undefined) return parsed.patch;\n    if (parsed.state !== undefined) return parsed.state;\n    return parsed;\n  }\n\n  function connect(key, label, url, ind) {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) {\n    return null;\n  }\n\n    const g = ensureGlobal();\n\n    // close any existing connection\n    try { g[key].es && g[key].es.close(); } catch {}\n    g[key].es = null;\n\n    const es = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(url));\n    g[key].es = es;\n\n\n    // Phase16: guard null EventSource before handlers\n    if (!es) return null;\n\n    const tick = () => set(ind, label, g[key].connected, g[key].lastAt);\n\n    es.onopen = () => { g[key].connected = true; tick(); };\n    es.onerror = () => { g[key].connected = false; tick(); };\n\n    const handle = (evtType, e) => {\n      g[key].lastAt = NOW();\n\n      const parsed = safeJsonParse(e && e.data ? e.data : \"\");\n      const payload = extractPayload(parsed);\n\n      if (isStateEvent(evtType, parsed)) {\n        // initial paint: replace\n        g[key].state = (payload && typeof payload === \"object\") ? payload : { value: payload };\n      } else {\n        // incremental: patch or merge\n        if (payload && typeof payload === \"object\") {\n          if (typeof payload.path === \"string\" && \"value\" in payload) {\n            g[key].state = applyDotPathPatch(g[key].state, payload);\n          } else {\n            g[key].state = shallowMerge(g[key].state, payload);\n          }\n        } else if (payload !== null && payload !== undefined) {\n          g[key].state = shallowMerge(g[key].state, { lastValue: payload });\n        }\n      }\n\n      tick();\n      try {\n        window.dispatchEvent(new CustomEvent(`mb:${key}:update`, {\n          detail: { event: evtType, state: g[key].state, raw: parsed }\n        }));\n      } catch {}\n    };\n\n    // Unnamed events (rare in your streams, but safe)\n    es.onmessage = (e) => handle(\"message\", e);\n\n    // Named events (your streams DO emit these)\n    const eventNames = [\n      \"hello\",\n      `${key}.state`,\n      `${key}.update`,\n      `${key}.patch`,\n      `${key}.delta`,\n      \"state\",\n      \"update\",\n      \"patch\",\n      \"delta\",\n    ];\n\n    for (const name of eventNames) {\n      try {\n        es.addEventListener(name, (e) => handle(name, e));\n      } catch {}\n    }\n\n    tick();\n  }\n\n  function findOpsAnchor() {\n    return (\n      document.getElementById(\"ops-pill\") ||\n      document.querySelector(\"[data-widget='ops-pill']\") ||\n      document.querySelector(\".ops-pill\") ||\n      document.querySelector(\"#ops\") ||\n      null\n    );\n  }\n\n  function findReflectionsAnchor() {\n    return (\n      document.getElementById(\"reflections-header\") ||\n      document.getElementById(\"reflections\") ||\n      document.querySelector(\"[data-panel='reflections']\") ||\n      document.querySelector(\".reflections\") ||\n      (() => {\n        const heads = Array.from(document.querySelectorAll(\"h1,h2,h3,h4,header,strong\"));\n        return heads.find(h => (h.textContent || \"\").toLowerCase().includes(\"reflections\")) || null;\n      })()\n    );\n  }\n\n  function boot() {\n    const opsInd = mount(findOpsAnchor(), \"ops-sse-indicator\", \"OPS SSE\");\n    const refInd = mount(findReflectionsAnchor(), \"reflections-sse-indicator\", \"Reflections SSE\");\n\n    connect(\"ops\", \"OPS SSE\", OPS_SSE_URL, opsInd);\n    connect(\"reflections\", \"Reflections SSE\", REFLECTIONS_SSE_URL, refInd);\n\n    // keep age ticking\n    setInterval(() => {\n      const g = ensureGlobal();\n      set(opsInd, \"OPS SSE\", g.ops.connected, g.ops.lastAt);\n      set(refInd, \"Reflections SSE\", g.reflections.connected, g.reflections.lastAt);\n    }, 1000);\n  }\n\n  document.readyState === \"loading\"\n    ? document.addEventListener(\"DOMContentLoaded\", boot, { once: true })\n    : boot();\n})();\n\n// PHASE16_CONNECT_GUARD_FIXED_1767139733\n", "// <0001fb02> Agent Status Row \u2013 live heartbeats from OPS SSE\n// - Renders status pills for Matilda, Cade, Effie, Atlas\n// - Listens to OPS SSE on port 3201\n// - Updates colors/text based on incoming status\n\n(() => {\n  const container = document.getElementById(\"agent-status-container\");\n  if (!container) {\n    console.warn(\"agent-status-row.js: #agent-status-container not found.\");\n    return;\n  }\n\n  // Clear placeholder text (e.g., \"Loading agents...\")\n  container.innerHTML = \"\";\n\n  const AGENTS = [\"Matilda\", \"Cade\", \"Effie\", \"Atlas\"];\n  const indicators = {};\n\n  const row = document.createElement(\"div\");\n  row.className = \"flex flex-wrap gap-4 items-center\";\n  container.appendChild(row);\n\n  AGENTS.forEach((name) => {\n    const pill = document.createElement(\"div\");\n    pill.className =\n      \"px-3 py-1 rounded-full bg-gray-700 text-sm flex items-center gap-2 shadow\";\n\n    const dot = document.createElement(\"span\");\n    dot.className = \"w-2 h-2 rounded-full bg-yellow-400\";\n\n    const label = document.createElement(\"span\");\n    label.textContent = `${name}: \u23F3`;\n\n    pill.dataset.agent = name.toLowerCase();\n    pill.append(dot, label);\n    row.appendChild(pill);\n\n    indicators[name.toLowerCase()] = { pill, dot, label };\n  });\n\n  const OPS_SSE_URL = `/events/ops`;\n  \n\n  const __DISABLE_OPTIONAL_SSE = (typeof window !== \"undefined\" && window.__DISABLE_OPTIONAL_SSE) === true;\n  if (__DISABLE_OPTIONAL_SSE) {\n    console.warn(\"[agent-status-row] Optional SSE disabled (Phase 16 pending):\", OPS_SSE_URL);\n    Object.keys(indicators).forEach((key) => applyVisual(key, \"unknown\"));\n    return;\n  }\nlet source;\n\n  try {\n    source = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(OPS_SSE_URL));\n  } catch (err) {\n    console.error(\"agent-status-row.js: Failed to open OPS SSE connection:\", err);\n    return;\n  }\n\n  function classifyStatus(statusString) {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) {\n    return null;\n  }\n\n    const s = (statusString || \"\").toLowerCase();\n    if (!s) return \"unknown\";\n    if (s.includes(\"error\") || s.includes(\"failed\") || s.includes(\"offline\")) {\n      return \"error\";\n    }\n    if (s.includes(\"online\") || s.includes(\"ready\") || s.includes(\"ok\")) {\n      return \"online\";\n    }\n    if (s.includes(\"queued\") || s.includes(\"pending\") || s.includes(\"init\")) {\n      return \"pending\";\n    }\n    return \"unknown\";\n  }\n\n  function applyVisual(agentKey, statusString) {\n    const indicator = indicators[agentKey];\n    if (!indicator) return;\n\n    const kind = classifyStatus(statusString);\n    const { pill, dot, label } = indicator;\n\n    // Reset base classes\n    dot.className = \"w-2 h-2 rounded-full\";\n    pill.classList.remove(\"border\", \"border-red-400\", \"border-green-400\", \"border-yellow-300\");\n\n    switch (kind) {\n      case \"online\":\n        dot.classList.add(\"bg-green-400\");\n        pill.classList.add(\"border\", \"border-green-400\");\n        break;\n      case \"error\":\n        dot.classList.add(\"bg-red-400\");\n        pill.classList.add(\"border\", \"border-red-400\");\n        break;\n      case \"pending\":\n        dot.classList.add(\"bg-yellow-300\");\n        pill.classList.add(\"border\", \"border-yellow-300\");\n        break;\n      case \"unknown\":\n      default:\n        dot.classList.add(\"bg-gray-500\");\n        break;\n    }\n\n    const prettyName = agentKey.charAt(0).toUpperCase() + agentKey.slice(1);\n    const finalStatus = statusString || \"unknown\";\n    label.textContent = `${prettyName}: ${finalStatus}`;\n  }\n\n  // Phase16: guard null EventSource before handlers\n  if (!source) return null;\n  source.onmessage = (event) => {\n    let payloadRaw = event.data;\n    let data;\n\n    try {\n      data = JSON.parse(payloadRaw);\n    } catch {\n      // If it's not JSON, ignore for agent-status purposes\n      return;\n    }\n\n    const agentName =\n      (data.agent || data.actor || data.source || data.worker || \"\").toString();\n    if (!agentName) return;\n\n    const key = agentName.toLowerCase();\n    if (!indicators[key]) {\n      // Ignore agents we don't show in the row\n      return;\n    }\n\n    const status = (data.status || data.state || data.level || \"\").toString() || \"unknown\";\n    applyVisual(key, status);\n  };\n\n  source.onerror = (err) => {\n    console.warn(\"agent-status-row.js: OPS SSE error:\", err);\n    // On error, show all as unknown (neutral gray)\n    Object.keys(indicators).forEach((key) => applyVisual(key, \"unknown\"));\n  };\n})();\n", "// <0001fad7> Phase 5.1 \u2014 Matilda \u2192 Cade \u2192 Effie Broadcast Visualization\n// Wrapped in a guarded init() so we don't create duplicate intervals on reload.\n\nconst BROADCAST_GUARD_KEY = \"__broadcastVisualizationInited\";\n\nconst nodes = [\"Matilda\", \"Cade\", \"Effie\"];\n\nfunction renderBroadcastNodes() {\nconst container = document.getElementById(\"broadcast-visual\");\nif (!container) return;\n\nconst parts = [];\nfor (let i = 0; i < nodes.length; i++) {\nconst n = nodes[i];\nparts.push('<div class=\"node\" id=\"node-' + n + '\">' + n + \"</div>\");\nif (i < nodes.length - 1) {\nparts.push('<div class=\"arrow\">\u279C</div>');\n}\n}\ncontainer.innerHTML = parts.join(\"\");\n}\n\nfunction startBroadcastCycle() {\nlet idx = 0;\n\nsetInterval(() => {\nconst allNodes = document.querySelectorAll(\".node\");\nallNodes.forEach((n) => n.classList.remove(\"active\"));\n\nconst activeId = \"node-\" + nodes[idx];\nconst active = document.getElementById(activeId);\nif (active) active.classList.add(\"active\");\n\nidx = (idx + 1) % nodes.length;\n\n}, 1500);\n}\n\n/**\n\n* Initialize the broadcast visualization in a guarded way so it\n* does not re-register intervals or duplicate DOM nodes.\n  */\n  export function initBroadcastVisualization() {\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n  return;\n  }\n\nif (window[BROADCAST_GUARD_KEY]) {\nreturn;\n}\nwindow[BROADCAST_GUARD_KEY] = true;\n\nconst run = () => {\nrenderBroadcastNodes();\nstartBroadcastCycle();\n};\n\nif (document.readyState === \"loading\") {\nwindow.addEventListener(\"DOMContentLoaded\", run);\n} else {\nrun();\n}\n}\n\n// Optional: expose for manual debugging in the browser console\nif (typeof window !== \"undefined\") {\nwindow.initBroadcastVisualization = initBroadcastVisualization;\n}\n", "// public/js/ops-status-widget.js\n// Phase 11: minimal pill ID normalizer; all state comes from ops-pill-state.js\n(function () {\n  if (typeof document === \"undefined\") return;\n\n  var existing = document.getElementById(\"ops-dashboard-pill\");\n  if (existing) return;\n\n  var pill = document.querySelector(\"[data-ops-pill]\");\n  if (!pill) return;\n\n  pill.id = \"ops-dashboard-pill\";\n})();\n", "// Lightweight OPS SSE \u2192 global state bridge for Phase 11\n(() => {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) return;\n\n  if (typeof window === \"undefined\" || typeof EventSource === \"undefined\") return;\n\n  // Avoid multiple initializations if bundle is loaded twice\n  if (window.__opsGlobalsBridgeInitialized) return;\n  window.__opsGlobalsBridgeInitialized = true;\n\n  // Initialize globals if they don't exist\n  if (typeof window.lastOpsHeartbeat === \"undefined\") {\n    window.lastOpsHeartbeat = null;\n  }\n  if (typeof window.lastOpsStatusSnapshot === \"undefined\") {\n    window.lastOpsStatusSnapshot = null;\n  }\n\n  const opsUrl = `/events/ops`;\n\n  \n\n  const __DISABLE_OPTIONAL_SSE = (typeof window !== \"undefined\" && window.__DISABLE_OPTIONAL_SSE) === true;\n  if (__DISABLE_OPTIONAL_SSE) {\n    console.warn(\"[ops-globals-bridge] Optional SSE disabled (Phase 16 pending):\", opsUrl);\n    return;\n  }\nconst handleEvent = (event) => {\n    try {\n      const data = JSON.parse(event.data || \"null\");\n      if (!data) return;\n\n      window.lastOpsHeartbeat = Math.floor(Date.now() / 1000);\n      window.lastOpsStatusSnapshot = data;\n    } catch (err) {\n      console.warn(\"[ops-globals-bridge] Failed to parse OPS event:\", err);\n    }\n  \n  // Phase16: emit a unified CustomEvent for OPS pill + listeners\n  try {\n    window.dispatchEvent(new CustomEvent(\"mb:ops:update\", {\n      detail: { event: \"message\", state: window.lastOpsStatusSnapshot }\n    }));\n  } catch {}\n};\n\n  try {\n    const es = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(opsUrl));\n\n    // Default unnamed \"message\" events (if any in future)\n    // Phase16: guard null EventSource before handlers\n\n    if (!es) return null;\n\n    es.onmessage = handleEvent;\n\n    // Named \"hello\" events from OPS SSE\n    es.addEventListener(\"hello\", handleEvent);\n\n    // Phase16: guard null EventSource before handlers (onerror)\n\n    if (!es) return;\n\n    es.onerror = (err) => {\n      console.warn(\"[ops-globals-bridge] EventSource error:\", err);\n    };\n  } catch (err) {\n    console.warn(\"[ops-globals-bridge] Failed to init EventSource:\", err);\n  }\n})();\n", "// public/js/ops-pill-state.js\n// Phase 11: simple dashboard OPS pill driven by lastOpsHeartbeat.\n// - Creates #ops-dashboard-pill on /dashboard if missing.\n// - Hides any external #ops-status-pill overlay.\n// - Shows \"OPS: Unknown\" / \"OPS: Online\" based on heartbeat.\n\n(function () {\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") return;\n  if (window.location.pathname !== \"/dashboard\") return;\n\n  var POLL_INTERVAL_MS = 5000;\n  var PILL_ID = \"ops-dashboard-pill\";\n\n  function ensurePill() {\n    var pill = document.getElementById(PILL_ID);\n    if (pill) return pill;\n\n    // Create the dashboard pill near the top of the body\n    pill = document.createElement(\"span\");\n    pill.id = PILL_ID;\n    pill.className = \"ops-pill ops-pill-unknown\";\n    pill.textContent = \"OPS: Unknown\";\n\n    // Keep styling minimal; main styles come from CSS class\n    pill.style.display = \"inline-block\";\n\n    if (document.body.firstChild) {\n      document.body.insertBefore(pill, document.body.firstChild);\n    } else {\n      document.body.appendChild(pill);\n    }\n\n    return pill;\n  }\n\n  function applyState() {\n    // Always hide any external overlay pill if present\n    var overlay = document.getElementById(\"ops-status-pill\");\n    if (overlay) {\n      overlay.style.display = \"none\";\n    }\n\n    var pill = ensurePill();\n    if (!pill) return;\n\n    var hasHeartbeat = (typeof window.lastOpsHeartbeat === \"number\");\n\n    var label = hasHeartbeat ? \"OPS: Online\"  : \"OPS: Unknown\";\n    var cls   = hasHeartbeat ? \"ops-pill-online\" : \"ops-pill-unknown\";\n\n    pill.classList.remove(\n      \"ops-pill-unknown\",\n      \"ops-pill-online\",\n      \"ops-pill-stale\",\n      \"ops-pill-error\"\n    );\n    pill.classList.add(cls);\n    pill.textContent = label;\n  }\n\n  applyState();\n  setInterval(applyState, POLL_INTERVAL_MS);\n})();\n", "/**\n * Tasks Widget (stable, no SSE)\n * - GET /api/tasks\n * - POST /api/complete-task\n * - No optimistic removal (prevents list blinking)\n */\n(() => {\n  const API = {\n    list: \"/api/tasks\",\n    complete: \"/api/complete-task\",\n  };\n\n  const SELECTORS = [\n    \"#tasks-widget\",\n    \"#tasksWidget\",\n    \"[data-tasks-widget]\",\n    \"[data-widget='tasks']\",\n  ];\n\n  const state = {\n    tasks: [],\n    loading: false,\n    lastError: null,\n    inflightComplete: new Set(),\n  };\n\n  function $(sel, root = document) {\n    return root.querySelector(sel);\n  }\n\n  function findMount() {\n    for (const sel of SELECTORS) {\n      const el = $(sel);\n      if (el) return el;\n    }\n    return null;\n  }\n\n  function esc(s) {\n    return String(s ?? \"\")\n      .replaceAll(\"&\", \"&amp;\")\n      .replaceAll(\"<\", \"&lt;\")\n      .replaceAll(\">\", \"&gt;\")\n      .replaceAll('\"', \"&quot;\")\n      .replaceAll(\"'\", \"&#39;\");\n  }\n\n  async function apiJson(url, opts = {}) {\n    const res = await fetch(url, {\n      method: opts.method || \"GET\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: opts.body ? JSON.stringify(opts.body) : undefined,\n    });\n    const json = await res.json();\n    if (!res.ok) throw new Error(json?.error || \"Request failed\");\n    return json;\n  }\n\n  async function fetchTasks() {\n    state.loading = true;\n    render();\n    try {\n      const data = await apiJson(API.list);\n      state.tasks = (data.tasks || []).map(t => ({\n        id: String(t.id),\n        title: t.title || \"\",\n        status: t.status || \"\",\n      }));\n    } catch (e) {\n      state.lastError = e.message;\n    } finally {\n      state.loading = false;\n      render();\n    }\n  }\n\n  async function completeTask(taskId) {\n    if (state.inflightComplete.has(taskId)) return;\n    state.inflightComplete.add(taskId);\n    render();\n\n    try {\n      await apiJson(API.complete, {\n        method: \"POST\",\n        body: { taskId },\n      });\n    } catch (e) {\n      state.lastError = e.message;\n    } finally {\n      state.inflightComplete.delete(taskId);\n      await fetchTasks();\n    }\n  }\n\n  function render() {\n    const mount = findMount();\n    if (!mount) return;\n\n    mount.innerHTML = `\n      <div>\n        \n        ${state.lastError ? `<div style=\"color:red\">${esc(state.lastError)}</div>` : \"\"}\n        <div>\n          ${state.tasks.map(t => `\n            <div style=\"display:flex;justify-content:space-between;gap:8px\">\n              <span>${esc(t.title)}</span>\n              ${\n                ([\"complete\",\"completed\",\"done\"].includes(String(t.status||\"\").toLowerCase()))\n                  ? `<span style=\"opacity:.5;font-size:12px\">Completed</span>`\n                  : `<button data-id=\"${t.id}\">Complete</button>`\n              }\n            </div>\n          `).join(\"\")}\n        </div>\n      </div>\n    `;\n\n    mount.querySelectorAll(\"button[data-id]\").forEach(btn => {\n      btn.onclick = () => completeTask(btn.dataset.id);\n    });\n  }\n\n  document.addEventListener(\"DOMContentLoaded\", fetchTasks);\n\n  // Phase22: SSE-driven refresh (ignore heartbeats)\n  window.addEventListener(\"mb.task.event\", (e) => {\n    const k = String(e?.detail?.kind || e?.detail?.type || \"\");\n    if (k === \"heartbeat\") return;\n    fetchTasks();\n  });\n\n// Phase22: SSE-driven refresh\n  window.addEventListener(\"mb.task.event\", () => { fetchTasks(); });\n\n// Auto-refresh (no SSE): keep widget feeling live\n  setInterval(() => { fetchTasks(); }, 5000);\n\n})();\n", "(function () {\n  function log(msg) {\n    console.log(\"[matilda-chat]\", msg);\n  }\n\n  function appendMessage(transcriptEl, sender, text) {\n    if (!transcriptEl) return;\n    var line = document.createElement(\"p\");\n    line.className = \"mb-1 text-sm\";\n    var label = sender ? sender + \": \" : \"\";\n    line.textContent = label + text;\n    transcriptEl.appendChild(line);\n    transcriptEl.scrollTop = transcriptEl.scrollHeight;\n  }\n\n  function setSendingState(sendBtn, input, isSending) {\n    if (sendBtn) {\n      sendBtn.disabled = isSending;\n      sendBtn.classList.toggle(\"opacity-60\", isSending);\n      sendBtn.textContent = isSending ? \"Sending...\" : \"Send\";\n    }\n    if (input) {\n      input.disabled = isSending;\n    }\n  }\n\n  async function wireChat() {\n    var root = document.getElementById(\"matilda-chat-root\");\n    if (!root) {\n      log(\"No #matilda-chat-root found; skipping wiring.\");\n      return;\n    }\n\n    var transcript = document.getElementById(\"matilda-chat-transcript\");\n    var input = document.getElementById(\"matilda-chat-input\");\n    var sendBtn = document.getElementById(\"matilda-chat-send\");\n\n    if (!transcript || !input || !sendBtn) {\n      log(\"Missing one or more Matilda chat elements; aborting wiring.\");\n      return;\n    }\n\n    function safeTrim(value) {\n      return (value || \"\").toString().trim();\n    }\n\n    async function handleSend() {\n      var message = safeTrim(input.value);\n      if (!message) return;\n\n      appendMessage(transcript, \"You\", message);\n      input.value = \"\";\n      setSendingState(sendBtn, input, true);\n\n      try {\n        var res = await fetch(\"/api/chat\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ message: message, agent: \"matilda\" }),\n        });\n\n        if (!res.ok) {\n          appendMessage(\n            transcript,\n            \"Matilda\",\n            \"(error talking to /api/chat)\"\n          );\n          return;\n        }\n\n        var data = await res.json();\n        var reply =\n          (data && (data.reply || data.message || data.response)) ||\n          \"(no reply)\";\n        appendMessage(transcript, \"Matilda\", reply);\n      } catch (err) {\n        console.error(err);\n        appendMessage(transcript, \"Matilda\", \"(network error)\");\n      } finally {\n        setSendingState(sendBtn, input, false);\n      }\n    }\n\n    sendBtn.addEventListener(\"click\", handleSend);\n\n    var quickBtn = document.getElementById(\"matilda-chat-quick-check\");\n    if (quickBtn) {\n      quickBtn.addEventListener(\"click\", function () {\n        input.value = \"Quick systems check from dashboard Phase 11.4.\";\n        handleSend();\n      });\n    }\n\n    input.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Enter\" && !e.shiftKey) {\n        e.preventDefault();\n        handleSend();\n      }\n    });\n\n    log(\"Matilda chat wiring complete.\");\n  }\n\n  document.addEventListener(\"DOMContentLoaded\", wireChat);\n})();\n", "(() => {\n  const SSE_URL = \"/events/task-events\";\n\n  const PANEL_ID = \"mb-task-events-panel\";\n  const FEED_ID = \"mb-task-events-feed\";\n  const COUNTS_ID = \"mb-task-events-counts\";\n  const ANCHOR_ID = \"mb-task-events-panel-anchor\";\n\n  function mountRoot() {\n    const anchor = document.getElementById(ANCHOR_ID);\n    if (anchor) return anchor;\n    return document.body;\n  }\n\n  function ensurePanel() {\n    if (document.getElementById(PANEL_ID)) return;\n\n    const root = mountRoot();\n\n    const panel = document.createElement(\"div\");\n    panel.id = PANEL_ID;\n\n    // If anchored, behave like an in-page card; otherwise float.\n    const anchored = root && root.id === ANCHOR_ID;\n\n    panel.style.width = anchored ? \"100%\" : \"360px\";\n    panel.style.maxWidth = anchored ? \"100%\" : \"calc(100vw - 24px)\";\n    panel.style.maxHeight = anchored ? \"260px\" : \"40vh\";\n    panel.style.overflow = \"hidden\";\n    panel.style.zIndex = \"9999\";\n    panel.style.border = \"1px solid rgba(255,255,255,0.12)\";\n    panel.style.borderRadius = \"14px\";\n    panel.style.background = \"rgba(10,10,14,0.92)\";\n    panel.style.backdropFilter = \"blur(10px)\";\n    panel.style.boxShadow = \"0 10px 30px rgba(0,0,0,0.35)\";\n    panel.style.color = \"rgba(255,255,255,0.92)\";\n    panel.style.fontFamily =\n      \"ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace\";\n\n    if (!anchored) {\n      panel.style.position = \"fixed\";\n      panel.style.right = \"12px\";\n      panel.style.bottom = \"12px\";\n    } else {\n      panel.style.marginTop = \"12px\";\n    }\n\n    const header = document.createElement(\"div\");\n    header.style.display = \"flex\";\n    header.style.alignItems = \"center\";\n    header.style.justifyContent = \"space-between\";\n    header.style.gap = \"8px\";\n    header.style.padding = \"10px 12px\";\n    header.style.borderBottom = \"1px solid rgba(255,255,255,0.10)\";\n\n    const title = document.createElement(\"div\");\n    title.textContent = \"TASK EVENTS (live)\";\n    title.style.fontSize = \"12px\";\n    title.style.letterSpacing = \"0.08em\";\n    title.style.opacity = \"0.9\";\n\n    const right = document.createElement(\"div\");\n    right.style.display = \"flex\";\n    right.style.alignItems = \"center\";\n    right.style.gap = \"10px\";\n\n    const counts = document.createElement(\"div\");\n    counts.id = COUNTS_ID;\n    counts.textContent = \"created:0  completed:0  failed:0\";\n    counts.style.fontSize = \"11px\";\n    counts.style.opacity = \"0.85\";\n\n    const dot = document.createElement(\"span\");\n    dot.setAttribute(\"aria-label\", \"task-events connection\");\n    dot.title = \"task-events connection\";\n    dot.style.display = \"inline-block\";\n    dot.style.width = \"10px\";\n    dot.style.height = \"10px\";\n    dot.style.borderRadius = \"999px\";\n    dot.style.background = \"rgba(255,255,255,0.25)\";\n    dot.style.boxShadow = \"0 0 0 2px rgba(255,255,255,0.08) inset\";\n\n    const btn = document.createElement(\"button\");\n    btn.type = \"button\";\n    btn.textContent = \"\u00D7\";\n    btn.title = \"hide\";\n    btn.style.cursor = \"pointer\";\n    btn.style.border = \"1px solid rgba(255,255,255,0.14)\";\n    btn.style.background = \"transparent\";\n    btn.style.color = \"rgba(255,255,255,0.85)\";\n    btn.style.borderRadius = \"10px\";\n    btn.style.width = \"28px\";\n    btn.style.height = \"24px\";\n    btn.style.lineHeight = \"22px\";\n    btn.style.fontSize = \"14px\";\n    btn.onclick = () => panel.remove();\n\n    right.appendChild(dot);\n    right.appendChild(counts);\n    right.appendChild(btn);\n\n    header.appendChild(title);\n    header.appendChild(right);\n\n    const feed = document.createElement(\"div\");\n    feed.id = FEED_ID;\n    feed.style.padding = \"10px 12px\";\n    feed.style.overflow = \"auto\";\n    feed.style.maxHeight = anchored ? \"200px\" : \"calc(40vh - 46px)\";\n\n    panel.appendChild(header);\n    panel.appendChild(feed);\n\n    root.appendChild(panel);\n\n    window.__MB_TASK_EVENTS_PANEL = { dot, feed, counts };\n    console.log(\"[phase22] task-events panel mounted (anchored=%s)\", anchored);\n  }\n\n  function setDot(state) {\n    ensurePanel();\n    const dot = window.__MB_TASK_EVENTS_PANEL?.dot;\n    if (!dot) return;\n    if (state === \"open\") dot.style.background = \"rgba(80,200,120,0.85)\";\n    else if (state === \"error\") dot.style.background = \"rgba(240,90,90,0.85)\";\n    else dot.style.background = \"rgba(255,255,255,0.25)\";\n  }\n\n  const seen = new Set();\n  const tally = { created: 0, completed: 0, failed: 0 };\n\n  function bumpCounts(kind) {\n    if (kind === \"task.created\") tally.created += 1;\n    if (kind === \"task.completed\") tally.completed += 1;\n    if (kind === \"task.failed\") tally.failed += 1;\n\n    const el = document.getElementById(COUNTS_ID);\n    if (el) el.textContent = `created:${tally.created}  completed:${tally.completed}  failed:${tally.failed}`;\n  }\n\n  function formatLine(ev, fallbackKind) {\n    const ts = typeof ev.ts === \"number\" ? new Date(ev.ts).toISOString() : new Date().toISOString();\n    const tid = ev.task_id ?? ev.id ?? ev.taskId ?? \"unknown\";\n    const run = ev.run_id ?? ev.runId ?? \"\";\n    const msg = ev.msg ?? ev.message ?? \"\";\n    const extras = [];\n    if (run) extras.push(`run=${run}`);\n    if (ev.actor) extras.push(`actor=${ev.actor}`);\n    if (ev.status) extras.push(`status=${ev.status}`);\n    if (typeof ev.cursor === \"number\") extras.push(`cursor=${ev.cursor}`);\n    const extraStr = extras.length ? ` (${extras.join(\" \")})` : \"\";\n    return `${ts}  ${(ev.kind ?? fallbackKind ?? \"event\")}  task=${tid}${extraStr}${msg ? \" \u2014 \" + msg : \"\"}`;\n  }\n\n  function appendLine(text, kind) {\n    ensurePanel();\n    const feed = document.getElementById(FEED_ID);\n    if (!feed) return;\n\n    const row = document.createElement(\"div\");\n    row.style.whiteSpace = \"pre-wrap\";\n    row.style.wordBreak = \"break-word\";\n    row.style.fontSize = \"11px\";\n    row.style.lineHeight = \"1.35\";\n    row.style.padding = \"6px 8px\";\n    row.style.border = \"1px solid rgba(255,255,255,0.10)\";\n    row.style.borderRadius = \"12px\";\n    row.style.marginBottom = \"8px\";\n    row.style.background = \"rgba(255,255,255,0.03)\";\n\n    if (kind === \"task.completed\") row.style.borderColor = \"rgba(80,200,120,0.35)\";\n    if (kind === \"task.failed\") row.style.borderColor = \"rgba(240,90,90,0.35)\";\n    if (kind === \"heartbeat\") row.style.opacity = \"0.65\";\n\n    row.textContent = text;\n    feed.prepend(row);\n\n    const children = Array.from(feed.children);\n    if (children.length > 60) {\n      for (let i = 60; i < children.length; i++) children[i].remove();\n    }\n  }\n\n  function dispatchWindowEvent(ev) {\n    try { window.dispatchEvent(new CustomEvent(\"mb.task.event\", { detail: ev })); } catch {}\n  }\n\n  function parseMaybeJSON(raw) {\n    try { return JSON.parse(raw); } catch { return null; }\n  }\n\n  function handleFrame(eventName, rawData) {\n    const data = typeof rawData === \"string\" ? parseMaybeJSON(rawData) : rawData;\n    const ev = (data && typeof data === \"object\") ? data : { kind: eventName, raw: rawData };\n\n      // Phase22 normalization:\n      // server sends event: task.event with payload { type:\"task.created|task.completed|task.failed\", taskId:\"...\" }\n      if (eventName === \"task.event\") {\n        if (!ev.kind && ev.type) ev.kind = ev.type;\n        if (ev.kind === \"task.event\" && ev.type) ev.kind = ev.type;\n        if (ev.task_id == null && ev.taskId != null) ev.task_id = ev.taskId;\n        if (ev.run_id == null && ev.runId != null) ev.run_id = ev.runId;\n      }\n\n    if (!ev.kind) ev.kind = eventName;\n\n    const key = `${eventName}|${ev.kind}|${ev.ts ?? \"\"}|${ev.task_id ?? ev.id ?? \"\"}|${ev.run_id ?? \"\"}|${ev.cursor ?? \"\"}`;\n    if (seen.has(key)) return;\n    seen.add(key);\n\n    if (ev.kind === \"task.created\" || ev.kind === \"task.completed\" || ev.kind === \"task.failed\") {\n      bumpCounts(String(ev.kind));\n    }\n\n    appendLine(formatLine(ev, eventName), String(ev.kind ?? eventName));\n    dispatchWindowEvent(ev);\n  }\n\n  let es = null;\n  let attempt = 0;\n\n  function connect() {\n    ensurePanel();\n\n    if (es) {\n      try { es.close(); } catch {}\n      es = null;\n    }\n\n    const url = SSE_URL;\n    es = new EventSource(url);\n\n    es.onopen = () => {\n      attempt = 0;\n      setDot(\"open\");\n      appendLine(`${new Date().toISOString()}  sse.open  url=${url}`, \"sse.open\");\n      console.log(\"[phase22] task-events SSE open\", url);\n    };\n\n    es.onerror = () => {\n      setDot(\"error\");\n      try { es.close(); } catch {}\n      es = null;\n\n      attempt += 1;\n      const delay = Math.min(15000, 500 * Math.pow(2, Math.min(6, attempt)));\n      appendLine(`${new Date().toISOString()}  sse.error  reconnect_in=${delay}ms`, \"sse.error\");\n      console.log(\"[phase22] task-events SSE error; reconnect in\", delay);\n      setTimeout(connect, delay);\n    };\n\n    es.onmessage = (msg) => handleFrame(\"message\", msg.data);\n\n    const names = [\n      \"hello\",\n      \"heartbeat\",\n      \"task.event\",\n      \"task.created\",\n      \"task.completed\",\n      \"task.failed\",\n      \"task.updated\",\n      \"task.status\",\n    ];\n    for (const name of names) {\n      es.addEventListener(name, (e) => handleFrame(name, e.data));\n    }\n  }\n\n  function boot() {\n    connect();\n    // Guard: if something removes the panel, re-mount + reconnect.\n    setInterval(() => {\n      if (!document.getElementById(PANEL_ID)) {\n        try { connect(); } catch {}\n      }\n    }, 2000);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", boot, { once: true });\n  } else {\n    boot();\n  }\n\n  window.__MB_TASK_EVENTS = { url: SSE_URL, reconnect: () => connect() };\n})();\n", "(() => {\n  // Phase 22: bind task-events SSE -> Task Delegation + status UI (best-effort)\n\n  const TASK_EVENT_NAME = \"mb.task.event\";\n  const tasks = new Map();\n\n  const STATUS_CLASS = {\n    queued: \"task-status-queued\",\n    done: \"task-status-done\",\n    failed: \"task-status-failed\",\n  };\n\n  function normStatus(s) {\n    const v = String(s ?? \"\").toLowerCase();\n    if (v === \"queued\" || v === \"pending\") return \"queued\";\n    if (v === \"done\" || v === \"complete\" || v === \"completed\") return \"done\";\n    if (v === \"failed\" || v === \"error\") return \"failed\";\n    return v || \"unknown\";\n  }\n\n  function pluckId(ev) {\n    return ev?.task_id ?? ev?.taskId ?? ev?.id ?? ev?.task?.id ?? null;\n  }\n\n  function pluckTask(ev) {\n    const t = ev?.task && typeof ev.task === \"object\" ? ev.task : null;\n    const id = pluckId(ev);\n    const status =\n      ev?.status ??\n      ev?.payload?.status ??\n      t?.status ??\n      (ev?.kind === \"task.created\" ? \"queued\" : null);\n\n    return {\n      id: id != null ? String(id) : null,\n      status: status != null ? normStatus(status) : null,\n      title: t?.title ?? ev?.title ?? null,\n      agent: t?.agent ?? ev?.agent ?? null,\n      error: ev?.error ?? ev?.payload?.error ?? t?.error ?? null,\n      updated_at: t?.updated_at ?? ev?.ts ?? Date.now(),\n    };\n  }\n\n  function setStatusOnNode(node, status) {\n    if (!node) return;\n    const s = normStatus(status);\n    node.setAttribute(\"data-task-status\", s);\n    node.classList?.remove(...Object.values(STATUS_CLASS));\n    if (STATUS_CLASS[s]) node.classList?.add(STATUS_CLASS[s]);\n\n    const sub =\n      node.querySelector?.(\"[data-task-field='status']\") ||\n      node.querySelector?.(\".task-status\") ||\n      node.querySelector?.(\".status\") ||\n      null;\n    if (sub) sub.textContent = s;\n  }\n\n  function updateTaskRowUI(task) {\n    if (!task?.id) return;\n    const id = String(task.id);\n    const nodes = [\n      document.getElementById(`task-${id}`),\n      document.getElementById(`task_${id}`),\n      document.querySelector?.(`[data-task-id=\"${CSS.escape(id)}\"]`),\n      document.querySelector?.(`[data-taskid=\"${CSS.escape(id)}\"]`),\n    ].filter(Boolean);\n\n    for (const n of nodes) setStatusOnNode(n, task.status);\n  }\n\n  function updateCountersUI() {\n    let queued = 0, done = 0, failed = 0;\n    for (const t of tasks.values()) {\n      const s = normStatus(t.status);\n      if (s === \"queued\") queued++;\n      else if (s === \"done\") done++;\n      else if (s === \"failed\") failed++;\n    }\n\n    const map = [\n      [\"queued\", queued],\n      [\"done\", done],\n      [\"failed\", failed],\n    ];\n\n    for (const [k, v] of map) {\n      const el =\n        document.getElementById(`task-count-${k}`) ||\n        document.getElementById(`tasks-${k}-count`) ||\n        document.querySelector?.(`[data-task-count=\"${k}\"]`) ||\n        null;\n      if (el) el.textContent = String(v);\n    }\n  }\n\n  function ingestTask(task) {\n    if (!task?.id) return;\n    const id = String(task.id);\n    const prev = tasks.get(id) || {};\n    const next = { ...prev, ...task, id, status: task.status ?? prev.status };\n    tasks.set(id, next);\n    updateTaskRowUI(next);\n    updateCountersUI();\n  }\n\n  function onTaskEvent(ev) {\n    const t = pluckTask(ev);\n    if (!t.id && ev?.kind) {\n      if (ev.kind === \"task.completed\") t.status = \"done\";\n      if (ev.kind === \"task.failed\") t.status = \"failed\";\n    }\n    if (t.id) ingestTask(t);\n  }\n\n  function attach() {\n    if (window.__PHASE22_TASK_UI_BOUND) return;\n    window.__PHASE22_TASK_UI_BOUND = true;\n\n    window.addEventListener(TASK_EVENT_NAME, (e) => {\n      try { if (window.__UI_DEBUG || window.__PHASE22_DEBUG) if (window.__UI_DEBUG || window.__PHASE22_DEBUG) console.log(\"[phase22] mb.task.event\", e.detail); onTaskEvent(e.detail); } catch {}\n    });\n\n    window.__PHASE22_TASK_UI = { tasks }; console.log(\"[phase22] bindings attached\");\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", attach, { once: true });\n  } else {\n    attach();\n  }\n})();\n", "import \"./sse-heartbeat-shim.js\";\nimport \"./heartbeat-stale-indicator.js\";\nimport \"./task-events-sse-listener.js\";\n// Phase 11 \u2013 Unified dashboard bundle entrypoint\n\n// Core dashboard status + tiles\nimport \"./dashboard-status.js\";\n\n// Phase 15/16 boundary: disable optional SSE (OPS + Reflections) until backends exist\nif (typeof window !== \"undefined\" && typeof window.__DISABLE_OPTIONAL_SSE === \"undefined\") {\n  window.__DISABLE_OPTIONAL_SSE = false;\n}\n\nimport \"./agent-status-row.js\";\n\n// OPS / PM2 status + SSE wiring\nimport \"./dashboard-broadcast.js\";\nimport \"./ops-status-widget.js\";\nimport \"./ops-globals-bridge.js\";\nimport \"./ops-pill-state.js\";\nimport \"./dashboard-tasks-widget.js\";\n\n// Matilda chat console wiring\nimport \"./matilda-chat-console.js\";\n\n// TEMP: dashboard graph disabled until canvas is present on all pages\n// import \"./dashboard-graph.js\";\n\n\n// Phase 22: task-events live UI\nimport \"./task-events-sse-client.js\";\nimport \"./phase22_task_delegation_live_bindings.js\";\n"],
- public/bundle.js:313:        "task.created",
- public/bundle.js:315:        "task.completed",
- public/bundle.js:316:        "task.failed",
- public/bundle.js:625:      if (s.includes("error") || s.includes("failed") || s.includes("offline")) {
- public/bundle.js:878:      if (!res.ok) throw new Error(json?.error || "Request failed");
- public/bundle.js:925:              ${["complete", "completed", "done"].includes(String(t.status || "").toLowerCase()) ? `<span style="opacity:.5;font-size:12px">Completed</span>` : `<button data-id="${t.id}">Complete</button>`}
- public/bundle.js:1093:      counts.textContent = "created:0  completed:0  failed:0";
- public/bundle.js:1144:    const tally = { created: 0, completed: 0, failed: 0 };
- public/bundle.js:1146:      if (kind === "task.created") tally.created += 1;
- public/bundle.js:1147:      if (kind === "task.completed") tally.completed += 1;
- public/bundle.js:1148:      if (kind === "task.failed") tally.failed += 1;
- public/bundle.js:1150:      if (el) el.textContent = `created:${tally.created}  completed:${tally.completed}  failed:${tally.failed}`;
- public/bundle.js:1179:      if (kind === "task.completed") row.style.borderColor = "rgba(80,200,120,0.35)";
- public/bundle.js:1180:      if (kind === "task.failed") row.style.borderColor = "rgba(240,90,90,0.35)";
- public/bundle.js:1215:      if (ev.kind === "task.created" || ev.kind === "task.completed" || ev.kind === "task.failed") {
- public/bundle.js:1258:        "task.created",
- public/bundle.js:1259:        "task.completed",
- public/bundle.js:1260:        "task.failed",
- public/bundle.js:1293:      done: "task-status-done",
- public/bundle.js:1294:      failed: "task-status-failed"
- public/bundle.js:1299:      if (v === "done" || v === "complete" || v === "completed") return "done";
- public/bundle.js:1300:      if (v === "failed" || v === "error") return "failed";
- public/bundle.js:1309:      const status = ev?.status ?? ev?.payload?.status ?? t?.status ?? (ev?.kind === "task.created" ? "queued" : null);
- public/bundle.js:1340:      let queued = 0, done = 0, failed = 0;
- public/bundle.js:1344:        else if (s === "done") done++;
- public/bundle.js:1345:        else if (s === "failed") failed++;
- public/bundle.js:1349:        ["done", done],
- public/bundle.js:1350:        ["failed", failed]
- public/bundle.js:1369:        if (ev.kind === "task.completed") t.status = "done";
- public/bundle.js:1370:        if (ev.kind === "task.failed") t.status = "failed";
- public/js/phase16_sse_owner_ops_reflections.js:41:        console.warn("[phase16] failed to create ops EventSource", e);
- public/js/phase16_sse_owner_ops_reflections.js:56:        console.warn("[phase16] failed to create reflections EventSource", e);
- public/js/task-delegation.js:31:            console.error('Delegation API call failed:', error);
- public/js/task-delegation.js:33:            messageDisplay.textContent = 'Delegation failed due to network error.';
- public/js/phase23_matilda_task_events_bridge.js:54:    if (type === "task.created") return { kind: "task.created", task: merged, id };
- public/js/phase23_matilda_task_events_bridge.js:55:    if (type === "task.completed") return { kind: "task.completed", task: merged, id };
- public/js/phase23_matilda_task_events_bridge.js:56:    if (type === "task.failed") return { kind: "task.failed", task: merged, id };
- public/js/phase23_matilda_task_events_bridge.js:59:    if (status in { queued: 1, running: 1, started: 1 }) return { kind: "task.progress", task: merged, id };
- public/js/phase23_matilda_task_events_bridge.js:60:    if (status in { completed: 1, done: 1, success: 1 }) return { kind: "task.completed", task: merged, id };
- public/js/phase23_matilda_task_events_bridge.js:61:    if (status in { failed: 1, error: 1 }) return { kind: "task.failed", task: merged, id };
- public/js/phase23_matilda_task_events_bridge.js:63:    return { kind: "task.progress", task: merged, id, raw: p };
- public/js/phase23_matilda_task_events_bridge.js:88:    if (kind === "task.created")   return `âœ¨ task.created [${id}]${a}${tail}`;
- public/js/phase23_matilda_task_events_bridge.js:89:    if (kind === "task.completed") return `ðŸŽ‰ task.completed [${id}]${a}${tail}`;
- public/js/phase23_matilda_task_events_bridge.js:90:    if (kind === "task.failed")    return `âŒ task.failed [${id}]${a}${tail}`;
- public/js/phase23_matilda_task_events_bridge.js:91:    if (kind === "task.progress")  return `â³ task.${(t.status || "update")} [${id}]${a}${tail}`;
- 
- ## 2) Row/DOM id patterns (risk of misused IDs)
- public/bundle.js:849:      "[data-tasks-widget]",
- public/bundle.js:925:              ${["complete", "completed", "done"].includes(String(t.status || "").toLowerCase()) ? `<span style="opacity:.5;font-size:12px">Completed</span>` : `<button data-id="${t.id}">Complete</button>`}
- public/bundle.js:931:      mount.querySelectorAll("button[data-id]").forEach((btn) => {
- public/bundle.js:932:        btn.onclick = () => completeTask(btn.dataset.id);
- public/bundle.js:1322:      node.setAttribute("data-task-status", s);
- public/bundle.js:1325:      const sub = node.querySelector?.("[data-task-field='status']") || node.querySelector?.(".task-status") || node.querySelector?.(".status") || null;
- public/bundle.js:1334:        document.querySelector?.(`[data-task-id="${CSS.escape(id)}"]`),
- public/bundle.js:1335:        document.querySelector?.(`[data-taskid="${CSS.escape(id)}"]`)
- public/bundle.js:1353:        const el = document.getElementById(`task-count-${k}`) || document.getElementById(`tasks-${k}-count`) || document.querySelector?.(`[data-task-count="${k}"]`) || null;
- public/js/phase22_task_delegation_live_bindings.js:47:    node.setAttribute("data-task-status", s);
- public/js/phase22_task_delegation_live_bindings.js:52:      node.querySelector?.("[data-task-field='status']") ||
- public/js/phase22_task_delegation_live_bindings.js:65:      document.querySelector?.(`[data-task-id="${CSS.escape(id)}"]`),
- public/js/phase22_task_delegation_live_bindings.js:66:      document.querySelector?.(`[data-taskid="${CSS.escape(id)}"]`),
- public/js/phase22_task_delegation_live_bindings.js:91:        document.querySelector?.(`[data-task-count="${k}"]`) ||
- public/js/dashboard-tasks-widget.js:16:    "[data-tasks-widget]",
- public/js/dashboard-tasks-widget.js:110:                  : `<button data-id="${t.id}">Complete</button>`
- public/js/dashboard-tasks-widget.js:118:    mount.querySelectorAll("button[data-id]").forEach(btn => {
- public/js/dashboard-tasks-widget.js:119:      btn.onclick = () => completeTask(btn.dataset.id);
- public/bundle.js.map:4:  "sourcesContent": ["/**\n * Phase 16 \u2013 Shared Heartbeat Bus (OPS + Tasks)\n *\n * Wrap EventSource so connection + any SSE message updates a normalized heartbeat store.\n *\n * Exposes:\n *   window.__HB = { record(kind, ts), get(kind), snapshot() }\n *\n * kind: \"ops\" | \"tasks\" | \"reflections\" | \"unknown\"\n */\n(function () {\n  const w = window;\n\n  const STORE_KEY = \"__HB\";\n  if (!w[STORE_KEY]) {\n    const state = { ops: null, tasks: null, reflections: null, unknown: null };\n    w[STORE_KEY] = {\n      record(kind, ts) {\n        const k = Object.prototype.hasOwnProperty.call(state, kind) ? kind : \"unknown\";\n        state[k] = typeof ts === \"number\" ? ts : Date.now();\n        return state[k];\n      },\n      get(kind) {\n        const k = Object.prototype.hasOwnProperty.call(state, kind) ? kind : \"unknown\";\n        return state[k];\n      },\n      snapshot() {\n        return { ...state };\n      },\n    };\n  }\n\n  const NativeEventSource = w.EventSource;\n  if (!NativeEventSource || NativeEventSource.__hbWrapped) return;\n\n  function classify(url) {\n    const u = String(url || \"\");\n    if (u.includes(\"/events/ops\")) return \"ops\";\n    if (u.includes(\"/events/tasks\")) return \"tasks\";\n    if (u.includes(\"/events/reflections\")) return \"reflections\";\n    return \"unknown\";\n  }\n\n  function HeartbeatEventSource(url, eventSourceInitDict) {\n    const kind = classify(url);\n\n    // Record immediately on connection attempt so \"connected but quiet\" still looks alive.\n    try { w[STORE_KEY].record(kind, Date.now()); } catch (_) {}\n\n    const es = new NativeEventSource(url, eventSourceInitDict);\n\n    const update = () => {\n      try { w[STORE_KEY].record(kind, Date.now()); } catch (_) {}\n    };\n\n    // Update heartbeat when the connection opens (most reliable for \"alive\").\n    try { es.addEventListener(\"open\", update); } catch (_) {}\n\n    // Update heartbeat on any message for this stream.\n    try { es.addEventListener(\"message\", update); } catch (_) {}\n\n    // Also wrap onmessage if assigned later.\n    let _onmessage = null;\n    Object.defineProperty(es, \"onmessage\", {\n      get() { return _onmessage; },\n      set(fn) {\n        _onmessage = function (ev) {\n          update();\n          if (typeof fn === \"function\") return fn.call(es, ev);\n        };\n      },\n      configurable: true,\n    });\n\n    // Update heartbeat when errors occur too (helps show \"something happened\" vs silence).\n    try { es.addEventListener(\"error\", update); } catch (_) {}\n\n    return es;\n  }\n\n  HeartbeatEventSource.prototype = NativeEventSource.prototype;\n  HeartbeatEventSource.__hbWrapped = true;\n\n  w.EventSource = HeartbeatEventSource;\n})();\n", "/**\n * Phase 16 \u2013 Heartbeat stale-state indicator (non-intrusive)\n *\n * Reads window.__HB (from sse-heartbeat-shim) and updates a tiny badge.\n * - Adds a badge to the top-right corner of the dashboard.\n * - Shows OK when both OPS+Tasks have recent heartbeats.\n * - Shows STALE when either stream is missing or old.\n *\n * No coupling to widget internals. Safe to remove.\n */\n(function () {\n  const w = window;\n  const HB = w.__HB;\n\n  function now() {\n    return Date.now();\n  }\n\n  function ms(n) {\n    return Math.max(0, Number(n) || 0);\n  }\n\n  // Consider heartbeats stale after this many ms.\n  const STALE_MS = 15000;\n\n  function fmtAge(ts) {\n    if (!ts) return \"\u2014\";\n    const s = Math.floor((now() - ts) / 1000);\n    return s <= 0 ? \"0s\" : `${s}s`;\n  }\n\n  function ensureBadge() {\n    let el = document.getElementById(\"hb-badge\");\n    if (el) return el;\n\n    el = document.createElement(\"div\");\n    el.id = \"hb-badge\";\n    el.setAttribute(\"role\", \"status\");\n    el.style.position = \"fixed\";\n    el.style.top = \"12px\";\n    el.style.right = \"12px\";\n    el.style.zIndex = \"9999\";\n    el.style.fontFamily = \"ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial\";\n    el.style.fontSize = \"12px\";\n    el.style.padding = \"6px 10px\";\n    el.style.borderRadius = \"999px\";\n    el.style.border = \"1px solid rgba(255,255,255,0.14)\";\n    el.style.background = \"rgba(0,0,0,0.55)\";\n    el.style.backdropFilter = \"blur(6px)\";\n    el.style.webkitBackdropFilter = \"blur(6px)\";\n    el.style.color = \"rgba(255,255,255,0.92)\";\n    el.style.boxShadow = \"0 8px 18px rgba(0,0,0,0.35)\";\n    el.style.userSelect = \"none\";\n    el.style.cursor = \"default\";\n    document.body.appendChild(el);\n    return el;\n  }\n\n  function setState(el, ok) {\n    // No colors specified by instruction in other contexts; keep neutral text-only signal.\n    // We\u2019ll use symbols instead of colored fills.\n    el.textContent = ok\n      ? `HB \u2713 (ops ${fmtAge(HB && HB.get(\"ops\"))}, tasks ${fmtAge(HB && HB.get(\"tasks\"))})`\n      : `HB ! (ops ${fmtAge(HB && HB.get(\"ops\"))}, tasks ${fmtAge(HB && HB.get(\"tasks\"))})`;\n  }\n\n  function tick() {\n    const el = ensureBadge();\n\n    if (!HB || typeof HB.get !== \"function\") {\n      el.textContent = \"HB ? (shim not loaded)\";\n      return;\n    }\n\n    const ops = HB.get(\"ops\");\n    const tasks = HB.get(\"tasks\");\n\n    const opsOk = !!ops && ms(now() - ops) <= STALE_MS;\n    const tasksOk = !!tasks && ms(now() - tasks) <= STALE_MS;\n\n    setState(el, opsOk && tasksOk);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      tick();\n      setInterval(tick, 1000);\n    });\n  } else {\n    tick();\n    setInterval(tick, 1000);\n  }\n})();\n", "/**\n * Phase 21: Task Events SSE listener\n * - Parallel to ops/reflections (does not modify their ownership)\n * - Opens EventSource(\"/events/task-events\")\n * - Buffers events on window.__TASK_EVENTS_FEED and emits DOM event \"task-events:append\"\n * - Tiny debug panel is ALWAYS clickable (collapsed by default)\n *   - Auto-expands when window.__UI_DEBUG or window.__PHASE21_SHOW_TASK_EVENTS is true\n * - Exposes window.__TASK_EVENTS snapshot for quick inspection\n */\n(function () {\n  const URL = \"/events/task-events\";\n  const MAX_ITEMS = 200;\n\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") return;\n  if (window.__TASK_EVENTS_SSE_INITED) return;\n  window.__TASK_EVENTS_SSE_INITED = true;\n\n  function nowIso() {\n    try { return new Date().toISOString(); } catch { return String(Date.now()); }\n  }\n\n  function ensureBuffer() {\n    if (!window.__TASK_EVENTS_FEED) window.__TASK_EVENTS_FEED = [];\n    return window.__TASK_EVENTS_FEED;\n  }\n\n  function ensureSnapshot() {\n    if (!window.__TASK_EVENTS) {\n      window.__TASK_EVENTS = {\n        url: URL,\n        connected: false,\n        lastAt: 0,\n        lastEvent: null,\n        cursor: null,\n        readyState: null,\n      };\n    }\n    return window.__TASK_EVENTS;\n  }\n\n  function pushItem(item) {\n    const buf = ensureBuffer();\n    buf.push(item);\n    if (buf.length > MAX_ITEMS) buf.splice(0, buf.length - MAX_ITEMS);\n\n    const snap = ensureSnapshot();\n    snap.lastAt = item.ts || Date.now();\n    snap.lastEvent = item.event || item.kind || null;\n    if (item?.data && typeof item.data === \"object\" && \"cursor\" in item.data) {\n      snap.cursor = item.data.cursor ?? snap.cursor;\n    }\n    try { snap.readyState = window.__taskEventsES?.readyState ?? null; } catch {}\n\n    try {\n      window.dispatchEvent(new CustomEvent(\"task-events:append\", { detail: item }));\n    } catch {}\n  }\n\n  function safeJson(s) {\n    try { return JSON.parse(s); } catch { return null; }\n  }\n\n  function ensureMiniPanel() {\n    if (document.getElementById(\"task-events-log\")) return;\n\n    const wrap = document.createElement(\"div\");\n    wrap.id = \"task-events-log\";\n    wrap.style.position = \"fixed\";\n    wrap.style.right = \"14px\";\n    wrap.style.bottom = \"14px\";\n    wrap.style.width = \"440px\";\n    wrap.style.maxHeight = \"240px\";\n    wrap.style.overflow = \"hidden\"; // body scrolls, header stays\n    wrap.style.padding = \"10px 12px\";\n    wrap.style.borderRadius = \"12px\";\n    wrap.style.fontFamily = \"ui-monospace, Menlo, Monaco, Consolas, monospace\";\n    wrap.style.fontSize = \"12px\";\n    wrap.style.lineHeight = \"1.35\";\n    wrap.style.zIndex = \"99999\";\n    wrap.style.background = \"rgba(10,10,14,0.72)\";\n    wrap.style.border = \"1px solid rgba(255,255,255,0.12)\";\n    wrap.style.boxShadow = \"0 10px 24px rgba(0,0,0,0.35)\";\n    wrap.style.backdropFilter = \"blur(6px)\";\n    wrap.style.display = \"block\"; // ALWAYS clickable\n\n    const hdr = document.createElement(\"div\");\n    hdr.style.display = \"flex\";\n    hdr.style.alignItems = \"center\";\n    hdr.style.justifyContent = \"space-between\";\n    hdr.style.gap = \"10px\";\n    hdr.style.marginBottom = \"8px\";\n\n    const title = document.createElement(\"div\");\n    title.id = \"task-events-log-title\";\n    title.textContent = \"TASK EVENTS \u00B7 disconnected\";\n    title.style.letterSpacing = \"0.12em\";\n    title.style.fontWeight = \"700\";\n    title.style.opacity = \"0.9\";\n\n    const btn = document.createElement(\"button\");\n    btn.type = \"button\";\n    btn.textContent = \"expand\";\n    btn.style.cursor = \"pointer\";\n    btn.style.border = \"1px solid rgba(255,255,255,0.15)\";\n    btn.style.background = \"rgba(255,255,255,0.08)\";\n    btn.style.color = \"rgba(255,255,255,0.9)\";\n    btn.style.borderRadius = \"10px\";\n    btn.style.padding = \"4px 8px\";\n    btn.style.fontSize = \"12px\";\n\n    const body = document.createElement(\"div\");\n    body.id = \"task-events-log-body\";\n    body.style.maxHeight = \"190px\";\n    body.style.overflow = \"auto\";\n    body.style.display = \"none\"; // collapsed by default\n\n    btn.onclick = () => {\n      const on = body.style.display === \"none\";\n      body.style.display = on ? \"block\" : \"none\";\n      btn.textContent = on ? \"collapse\" : \"expand\";\n    };\n\n    hdr.appendChild(title);\n    hdr.appendChild(btn);\n\n    wrap.appendChild(hdr);\n    wrap.appendChild(body);\n    document.body.appendChild(wrap);\n\n    // Auto-expand when debugging\n    if (window.__UI_DEBUG || window.__PHASE21_SHOW_TASK_EVENTS) {\n      body.style.display = \"block\";\n      btn.textContent = \"collapse\";\n    }\n  }\n\n  function appendLine(text) {\n    const body = document.getElementById(\"task-events-log-body\");\n    if (!body) return;\n    const div = document.createElement(\"div\");\n    div.style.whiteSpace = \"pre-wrap\";\n    div.style.wordBreak = \"break-word\";\n    div.textContent = text;\n    body.appendChild(div);\n    while (body.childNodes.length > 140) body.removeChild(body.firstChild);\n    body.scrollTop = body.scrollHeight;\n  }\n\n  function setHeaderStatus(text) {\n    const t = document.getElementById(\"task-events-log-title\");\n    if (t) t.textContent = text;\n  }\n\n  function start() {\n    ensureMiniPanel();\n    ensureSnapshot();\n\n    const es = new EventSource(URL);\n    window.__taskEventsES = es;\n\n    es.onopen = () => {\n      const snap = ensureSnapshot();\n      snap.connected = true;\n      snap.readyState = es.readyState;\n\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"sse.open\", event: \"open\", url: URL };\n      pushItem(item);\n      setHeaderStatus(\"TASK EVENTS \u00B7 connected\");\n      appendLine(`[${item.iso}] open ${URL}`);\n    };\n\n    es.onerror = () => {\n      const snap = ensureSnapshot();\n      snap.connected = false;\n      snap.readyState = es.readyState;\n\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"sse.error\", event: \"error\", url: URL, readyState: es.readyState };\n      pushItem(item);\n      setHeaderStatus(`TASK EVENTS \u00B7 error (readyState=${es.readyState})`);\n      appendLine(`[${item.iso}] error readyState=${es.readyState}`);\n    };\n\n    // default \"message\"\n    es.onmessage = (ev) => {\n      const payload = safeJson(ev.data);\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"message\", event: \"message\", data: payload ?? ev.data };\n      pushItem(item);\n      appendLine(`[${item.iso}] message :: ${payload ? JSON.stringify(payload) : String(ev.data)}`);\n    };\n\n    // named events (include what server ACTUALLY emits: task.event)\n    const names = [\n      \"hello\",\n      \"heartbeat\",\n      \"task.event\",\n      \"task.lifecycle\",\n      \"task.created\",\n      \"task.updated\",\n      \"task.completed\",\n      \"task.failed\",\n      \"error\",\n    ];\n\n    for (const name of names) {\n      try {\n        es.addEventListener(name, (ev) => {\n          const payload = safeJson(ev.data);\n          const item = { ts: Date.now(), iso: nowIso(), kind: \"event\", event: name, data: payload ?? ev.data };\n          pushItem(item);\n          appendLine(`[${item.iso}] ${name} :: ${payload ? JSON.stringify(payload) : String(ev.data)}`);\n        });\n      } catch {}\n    }\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", start, { once: true });\n  } else {\n    start();\n  }\n})();\n", "/**\n * Phase 16: Dashboard wiring for OPS + Reflections SSE streams.\n *\n * - Consume /events/ops + /events/reflections via EventSource\n * - Treat *.state as \"initial paint\" (replace baseline state)\n * - Treat subsequent events as incremental updates (merge / patch)\n * - Add tiny \u201Cconnected / last event\u201D UI indicator for each stream\n *\n * NOTE: Your SSE server emits NAMED events (e.g. \"ops.state\", \"reflections.state\").\n * EventSource.onmessage only receives UNNAMED events, so we must addEventListener()\n * for the named event types we care about.\n */\n\n(() => {\n  \"use strict\";\n\n  const OPS_SSE_URL = \"/events/ops\";\n  const REFLECTIONS_SSE_URL = \"/events/reflections\";\n\n  const NOW = () => Date.now();\n\n  function safeJsonParse(s) {\n    try { return JSON.parse(s); } catch { return null; }\n  }\n\n  function formatAge(ms) {\n    if (!Number.isFinite(ms)) return \"\u2014\";\n    const s = Math.floor(ms / 1000);\n    if (s < 60) return `${s}s`;\n    const m = Math.floor(s / 60);\n    if (m < 60) return `${m}m`;\n    return `${Math.floor(m / 60)}h`;\n  }\n\n  function el(tag, attrs = {}, text = \"\") {\n    const n = document.createElement(tag);\n    for (const [k, v] of Object.entries(attrs)) {\n      if (k === \"class\") n.className = v;\n      else if (k === \"style\") n.setAttribute(\"style\", v);\n      else n.setAttribute(k, v);\n    }\n    if (text) n.textContent = text;\n    return n;\n  }\n\n  function ensureStyles() {\n    if (document.getElementById(\"phase16-sse-style\")) return;\n    const s = el(\"style\", { id: \"phase16-sse-style\" });\n    s.textContent = `\n      .sse-indicator {\n        display:inline-flex;\n        align-items:center;\n        gap:6px;\n        font-size:11px;\n        line-height:1;\n        opacity:.85;\n        user-select:none;\n        white-space:nowrap;\n      }\n      .sse-indicator .dot {\n        width:7px; height:7px; border-radius:999px;\n        background:#555;\n        box-shadow:0 0 0 1px rgba(255,255,255,.08) inset;\n      }\n      .sse-indicator[data-connected=\"true\"] .dot { background:#2dd4bf; }\n      .sse-indicator[data-connected=\"false\"] .dot { background:#f97316; }\n      .sse-indicator .meta { font-variant-numeric: tabular-nums; }\n    `;\n    document.head.appendChild(s);\n  }\n\n  function mount(anchor, id, label) {\n    ensureStyles();\n\n    if (!anchor) {\n      let tray = document.getElementById(\"phase16-sse-tray\");\n      if (!tray) {\n        tray = el(\"div\", {\n          id: \"phase16-sse-tray\",\n          style: [\n            \"position:fixed\",\n            \"left:10px\",\n            \"bottom:10px\",\n            \"display:flex\",\n            \"flex-direction:column\",\n            \"gap:6px\",\n            \"z-index:9999\",\n            \"pointer-events:none\",\n          ].join(\";\")\n        });\n        document.body.appendChild(tray);\n      }\n      anchor = tray;\n    }\n\n    let node = document.getElementById(id);\n    if (node) return node;\n\n    node = el(\"span\", { id, class: \"sse-indicator\", \"data-connected\": \"false\" });\n    node.append(\n      el(\"span\", { class: \"dot\", \"aria-hidden\": \"true\" }),\n      el(\"span\", { class: \"meta\" }, `${label}: disconnected \u00B7 last: \u2014`)\n    );\n\n    // try to place nicely; otherwise append\n    try {\n      if (anchor.matches && anchor.matches(\"header,h1,h2,h3,h4,strong\")) {\n        const wrap = el(\"span\", { style: \"margin-left:8px\" });\n        wrap.appendChild(node);\n        anchor.appendChild(wrap);\n      } else {\n        const wrap = el(\"div\", { style: \"margin-top:4px\" });\n        wrap.appendChild(node);\n        anchor.appendChild(wrap);\n      }\n    } catch {\n      anchor.appendChild(node);\n    }\n\n    return node;\n  }\n\n  function set(ind, label, connected, lastAt) {\n    if (!ind) return;\n    ind.dataset.connected = connected ? \"true\" : \"false\";\n    const meta = ind.querySelector(\".meta\");\n    if (!meta) return;\n    meta.textContent = `${label}: ${connected ? \"connected\" : \"disconnected\"} \u00B7 last: ${lastAt ? formatAge(NOW() - lastAt) : \"\u2014\"}`;\n  }\n\n  function ensureGlobal() {\n    window.__MB_STREAMS ||= {\n      ops: { connected: false, lastAt: 0, state: {}, es: null },\n      reflections: { connected: false, lastAt: 0, state: {}, es: null },\n    };\n    return window.__MB_STREAMS;\n  }\n\n  function shallowMerge(target, patch) {\n    if (!target || typeof target !== \"object\") target = {};\n    if (!patch || typeof patch !== \"object\") return target;\n    return Object.assign(target, patch);\n  }\n\n  // Minimal dot-path patch support: { path:\"a.b.c\", value:any }\n  function applyDotPathPatch(state, patch) {\n    if (!state || typeof state !== \"object\") state = {};\n    const path = patch && typeof patch.path === \"string\" ? patch.path : \"\";\n    if (!path) return state;\n    const parts = path.split(\".\").filter(Boolean);\n    if (!parts.length) return state;\n    let cur = state;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const k = parts[i];\n      if (!cur[k] || typeof cur[k] !== \"object\") cur[k] = {};\n      cur = cur[k];\n    }\n    cur[parts[parts.length - 1]] = patch.value;\n    return state;\n  }\n\n  function isStateEvent(evtType, parsed) {\n    if (typeof evtType === \"string\" && evtType.endsWith(\".state\")) return true;\n    if (parsed && typeof parsed === \"object\") {\n      if (parsed.state && typeof parsed.state === \"object\") return true;\n      if (typeof parsed.type === \"string\" && parsed.type.includes(\"state\")) return true;\n      if (typeof parsed.event === \"string\" && parsed.event.includes(\"state\")) return true;\n    }\n    return false;\n  }\n\n  function extractPayload(parsed) {\n    if (!parsed || typeof parsed !== \"object\") return parsed;\n    if (parsed.payload !== undefined) return parsed.payload;\n    if (parsed.data !== undefined) return parsed.data;\n    if (parsed.delta !== undefined) return parsed.delta;\n    if (parsed.patch !== undefined) return parsed.patch;\n    if (parsed.state !== undefined) return parsed.state;\n    return parsed;\n  }\n\n  function connect(key, label, url, ind) {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) {\n    return null;\n  }\n\n    const g = ensureGlobal();\n\n    // close any existing connection\n    try { g[key].es && g[key].es.close(); } catch {}\n    g[key].es = null;\n\n    const es = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(url));\n    g[key].es = es;\n\n\n    // Phase16: guard null EventSource before handlers\n    if (!es) return null;\n\n    const tick = () => set(ind, label, g[key].connected, g[key].lastAt);\n\n    es.onopen = () => { g[key].connected = true; tick(); };\n    es.onerror = () => { g[key].connected = false; tick(); };\n\n    const handle = (evtType, e) => {\n      g[key].lastAt = NOW();\n\n      const parsed = safeJsonParse(e && e.data ? e.data : \"\");\n      const payload = extractPayload(parsed);\n\n      if (isStateEvent(evtType, parsed)) {\n        // initial paint: replace\n        g[key].state = (payload && typeof payload === \"object\") ? payload : { value: payload };\n      } else {\n        // incremental: patch or merge\n        if (payload && typeof payload === \"object\") {\n          if (typeof payload.path === \"string\" && \"value\" in payload) {\n            g[key].state = applyDotPathPatch(g[key].state, payload);\n          } else {\n            g[key].state = shallowMerge(g[key].state, payload);\n          }\n        } else if (payload !== null && payload !== undefined) {\n          g[key].state = shallowMerge(g[key].state, { lastValue: payload });\n        }\n      }\n\n      tick();\n      try {\n        window.dispatchEvent(new CustomEvent(`mb:${key}:update`, {\n          detail: { event: evtType, state: g[key].state, raw: parsed }\n        }));\n      } catch {}\n    };\n\n    // Unnamed events (rare in your streams, but safe)\n    es.onmessage = (e) => handle(\"message\", e);\n\n    // Named events (your streams DO emit these)\n    const eventNames = [\n      \"hello\",\n      `${key}.state`,\n      `${key}.update`,\n      `${key}.patch`,\n      `${key}.delta`,\n      \"state\",\n      \"update\",\n      \"patch\",\n      \"delta\",\n    ];\n\n    for (const name of eventNames) {\n      try {\n        es.addEventListener(name, (e) => handle(name, e));\n      } catch {}\n    }\n\n    tick();\n  }\n\n  function findOpsAnchor() {\n    return (\n      document.getElementById(\"ops-pill\") ||\n      document.querySelector(\"[data-widget='ops-pill']\") ||\n      document.querySelector(\".ops-pill\") ||\n      document.querySelector(\"#ops\") ||\n      null\n    );\n  }\n\n  function findReflectionsAnchor() {\n    return (\n      document.getElementById(\"reflections-header\") ||\n      document.getElementById(\"reflections\") ||\n      document.querySelector(\"[data-panel='reflections']\") ||\n      document.querySelector(\".reflections\") ||\n      (() => {\n        const heads = Array.from(document.querySelectorAll(\"h1,h2,h3,h4,header,strong\"));\n        return heads.find(h => (h.textContent || \"\").toLowerCase().includes(\"reflections\")) || null;\n      })()\n    );\n  }\n\n  function boot() {\n    const opsInd = mount(findOpsAnchor(), \"ops-sse-indicator\", \"OPS SSE\");\n    const refInd = mount(findReflectionsAnchor(), \"reflections-sse-indicator\", \"Reflections SSE\");\n\n    connect(\"ops\", \"OPS SSE\", OPS_SSE_URL, opsInd);\n    connect(\"reflections\", \"Reflections SSE\", REFLECTIONS_SSE_URL, refInd);\n\n    // keep age ticking\n    setInterval(() => {\n      const g = ensureGlobal();\n      set(opsInd, \"OPS SSE\", g.ops.connected, g.ops.lastAt);\n      set(refInd, \"Reflections SSE\", g.reflections.connected, g.reflections.lastAt);\n    }, 1000);\n  }\n\n  document.readyState === \"loading\"\n    ? document.addEventListener(\"DOMContentLoaded\", boot, { once: true })\n    : boot();\n})();\n\n// PHASE16_CONNECT_GUARD_FIXED_1767139733\n", "// <0001fb02> Agent Status Row \u2013 live heartbeats from OPS SSE\n// - Renders status pills for Matilda, Cade, Effie, Atlas\n// - Listens to OPS SSE on port 3201\n// - Updates colors/text based on incoming status\n\n(() => {\n  const container = document.getElementById(\"agent-status-container\");\n  if (!container) {\n    console.warn(\"agent-status-row.js: #agent-status-container not found.\");\n    return;\n  }\n\n  // Clear placeholder text (e.g., \"Loading agents...\")\n  container.innerHTML = \"\";\n\n  const AGENTS = [\"Matilda\", \"Cade\", \"Effie\", \"Atlas\"];\n  const indicators = {};\n\n  const row = document.createElement(\"div\");\n  row.className = \"flex flex-wrap gap-4 items-center\";\n  container.appendChild(row);\n\n  AGENTS.forEach((name) => {\n    const pill = document.createElement(\"div\");\n    pill.className =\n      \"px-3 py-1 rounded-full bg-gray-700 text-sm flex items-center gap-2 shadow\";\n\n    const dot = document.createElement(\"span\");\n    dot.className = \"w-2 h-2 rounded-full bg-yellow-400\";\n\n    const label = document.createElement(\"span\");\n    label.textContent = `${name}: \u23F3`;\n\n    pill.dataset.agent = name.toLowerCase();\n    pill.append(dot, label);\n    row.appendChild(pill);\n\n    indicators[name.toLowerCase()] = { pill, dot, label };\n  });\n\n  const OPS_SSE_URL = `/events/ops`;\n  \n\n  const __DISABLE_OPTIONAL_SSE = (typeof window !== \"undefined\" && window.__DISABLE_OPTIONAL_SSE) === true;\n  if (__DISABLE_OPTIONAL_SSE) {\n    console.warn(\"[agent-status-row] Optional SSE disabled (Phase 16 pending):\", OPS_SSE_URL);\n    Object.keys(indicators).forEach((key) => applyVisual(key, \"unknown\"));\n    return;\n  }\nlet source;\n\n  try {\n    source = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(OPS_SSE_URL));\n  } catch (err) {\n    console.error(\"agent-status-row.js: Failed to open OPS SSE connection:\", err);\n    return;\n  }\n\n  function classifyStatus(statusString) {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) {\n    return null;\n  }\n\n    const s = (statusString || \"\").toLowerCase();\n    if (!s) return \"unknown\";\n    if (s.includes(\"error\") || s.includes(\"failed\") || s.includes(\"offline\")) {\n      return \"error\";\n    }\n    if (s.includes(\"online\") || s.includes(\"ready\") || s.includes(\"ok\")) {\n      return \"online\";\n    }\n    if (s.includes(\"queued\") || s.includes(\"pending\") || s.includes(\"init\")) {\n      return \"pending\";\n    }\n    return \"unknown\";\n  }\n\n  function applyVisual(agentKey, statusString) {\n    const indicator = indicators[agentKey];\n    if (!indicator) return;\n\n    const kind = classifyStatus(statusString);\n    const { pill, dot, label } = indicator;\n\n    // Reset base classes\n    dot.className = \"w-2 h-2 rounded-full\";\n    pill.classList.remove(\"border\", \"border-red-400\", \"border-green-400\", \"border-yellow-300\");\n\n    switch (kind) {\n      case \"online\":\n        dot.classList.add(\"bg-green-400\");\n        pill.classList.add(\"border\", \"border-green-400\");\n        break;\n      case \"error\":\n        dot.classList.add(\"bg-red-400\");\n        pill.classList.add(\"border\", \"border-red-400\");\n        break;\n      case \"pending\":\n        dot.classList.add(\"bg-yellow-300\");\n        pill.classList.add(\"border\", \"border-yellow-300\");\n        break;\n      case \"unknown\":\n      default:\n        dot.classList.add(\"bg-gray-500\");\n        break;\n    }\n\n    const prettyName = agentKey.charAt(0).toUpperCase() + agentKey.slice(1);\n    const finalStatus = statusString || \"unknown\";\n    label.textContent = `${prettyName}: ${finalStatus}`;\n  }\n\n  // Phase16: guard null EventSource before handlers\n  if (!source) return null;\n  source.onmessage = (event) => {\n    let payloadRaw = event.data;\n    let data;\n\n    try {\n      data = JSON.parse(payloadRaw);\n    } catch {\n      // If it's not JSON, ignore for agent-status purposes\n      return;\n    }\n\n    const agentName =\n      (data.agent || data.actor || data.source || data.worker || \"\").toString();\n    if (!agentName) return;\n\n    const key = agentName.toLowerCase();\n    if (!indicators[key]) {\n      // Ignore agents we don't show in the row\n      return;\n    }\n\n    const status = (data.status || data.state || data.level || \"\").toString() || \"unknown\";\n    applyVisual(key, status);\n  };\n\n  source.onerror = (err) => {\n    console.warn(\"agent-status-row.js: OPS SSE error:\", err);\n    // On error, show all as unknown (neutral gray)\n    Object.keys(indicators).forEach((key) => applyVisual(key, \"unknown\"));\n  };\n})();\n", "// <0001fad7> Phase 5.1 \u2014 Matilda \u2192 Cade \u2192 Effie Broadcast Visualization\n// Wrapped in a guarded init() so we don't create duplicate intervals on reload.\n\nconst BROADCAST_GUARD_KEY = \"__broadcastVisualizationInited\";\n\nconst nodes = [\"Matilda\", \"Cade\", \"Effie\"];\n\nfunction renderBroadcastNodes() {\nconst container = document.getElementById(\"broadcast-visual\");\nif (!container) return;\n\nconst parts = [];\nfor (let i = 0; i < nodes.length; i++) {\nconst n = nodes[i];\nparts.push('<div class=\"node\" id=\"node-' + n + '\">' + n + \"</div>\");\nif (i < nodes.length - 1) {\nparts.push('<div class=\"arrow\">\u279C</div>');\n}\n}\ncontainer.innerHTML = parts.join(\"\");\n}\n\nfunction startBroadcastCycle() {\nlet idx = 0;\n\nsetInterval(() => {\nconst allNodes = document.querySelectorAll(\".node\");\nallNodes.forEach((n) => n.classList.remove(\"active\"));\n\nconst activeId = \"node-\" + nodes[idx];\nconst active = document.getElementById(activeId);\nif (active) active.classList.add(\"active\");\n\nidx = (idx + 1) % nodes.length;\n\n}, 1500);\n}\n\n/**\n\n* Initialize the broadcast visualization in a guarded way so it\n* does not re-register intervals or duplicate DOM nodes.\n  */\n  export function initBroadcastVisualization() {\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n  return;\n  }\n\nif (window[BROADCAST_GUARD_KEY]) {\nreturn;\n}\nwindow[BROADCAST_GUARD_KEY] = true;\n\nconst run = () => {\nrenderBroadcastNodes();\nstartBroadcastCycle();\n};\n\nif (document.readyState === \"loading\") {\nwindow.addEventListener(\"DOMContentLoaded\", run);\n} else {\nrun();\n}\n}\n\n// Optional: expose for manual debugging in the browser console\nif (typeof window !== \"undefined\") {\nwindow.initBroadcastVisualization = initBroadcastVisualization;\n}\n", "// public/js/ops-status-widget.js\n// Phase 11: minimal pill ID normalizer; all state comes from ops-pill-state.js\n(function () {\n  if (typeof document === \"undefined\") return;\n\n  var existing = document.getElementById(\"ops-dashboard-pill\");\n  if (existing) return;\n\n  var pill = document.querySelector(\"[data-ops-pill]\");\n  if (!pill) return;\n\n  pill.id = \"ops-dashboard-pill\";\n})();\n", "// Lightweight OPS SSE \u2192 global state bridge for Phase 11\n(() => {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) return;\n\n  if (typeof window === \"undefined\" || typeof EventSource === \"undefined\") return;\n\n  // Avoid multiple initializations if bundle is loaded twice\n  if (window.__opsGlobalsBridgeInitialized) return;\n  window.__opsGlobalsBridgeInitialized = true;\n\n  // Initialize globals if they don't exist\n  if (typeof window.lastOpsHeartbeat === \"undefined\") {\n    window.lastOpsHeartbeat = null;\n  }\n  if (typeof window.lastOpsStatusSnapshot === \"undefined\") {\n    window.lastOpsStatusSnapshot = null;\n  }\n\n  const opsUrl = `/events/ops`;\n\n  \n\n  const __DISABLE_OPTIONAL_SSE = (typeof window !== \"undefined\" && window.__DISABLE_OPTIONAL_SSE) === true;\n  if (__DISABLE_OPTIONAL_SSE) {\n    console.warn(\"[ops-globals-bridge] Optional SSE disabled (Phase 16 pending):\", opsUrl);\n    return;\n  }\nconst handleEvent = (event) => {\n    try {\n      const data = JSON.parse(event.data || \"null\");\n      if (!data) return;\n\n      window.lastOpsHeartbeat = Math.floor(Date.now() / 1000);\n      window.lastOpsStatusSnapshot = data;\n    } catch (err) {\n      console.warn(\"[ops-globals-bridge] Failed to parse OPS event:\", err);\n    }\n  \n  // Phase16: emit a unified CustomEvent for OPS pill + listeners\n  try {\n    window.dispatchEvent(new CustomEvent(\"mb:ops:update\", {\n      detail: { event: \"message\", state: window.lastOpsStatusSnapshot }\n    }));\n  } catch {}\n};\n\n  try {\n    const es = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(opsUrl));\n\n    // Default unnamed \"message\" events (if any in future)\n    // Phase16: guard null EventSource before handlers\n\n    if (!es) return null;\n\n    es.onmessage = handleEvent;\n\n    // Named \"hello\" events from OPS SSE\n    es.addEventListener(\"hello\", handleEvent);\n\n    // Phase16: guard null EventSource before handlers (onerror)\n\n    if (!es) return;\n\n    es.onerror = (err) => {\n      console.warn(\"[ops-globals-bridge] EventSource error:\", err);\n    };\n  } catch (err) {\n    console.warn(\"[ops-globals-bridge] Failed to init EventSource:\", err);\n  }\n})();\n", "// public/js/ops-pill-state.js\n// Phase 11: simple dashboard OPS pill driven by lastOpsHeartbeat.\n// - Creates #ops-dashboard-pill on /dashboard if missing.\n// - Hides any external #ops-status-pill overlay.\n// - Shows \"OPS: Unknown\" / \"OPS: Online\" based on heartbeat.\n\n(function () {\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") return;\n  if (window.location.pathname !== \"/dashboard\") return;\n\n  var POLL_INTERVAL_MS = 5000;\n  var PILL_ID = \"ops-dashboard-pill\";\n\n  function ensurePill() {\n    var pill = document.getElementById(PILL_ID);\n    if (pill) return pill;\n\n    // Create the dashboard pill near the top of the body\n    pill = document.createElement(\"span\");\n    pill.id = PILL_ID;\n    pill.className = \"ops-pill ops-pill-unknown\";\n    pill.textContent = \"OPS: Unknown\";\n\n    // Keep styling minimal; main styles come from CSS class\n    pill.style.display = \"inline-block\";\n\n    if (document.body.firstChild) {\n      document.body.insertBefore(pill, document.body.firstChild);\n    } else {\n      document.body.appendChild(pill);\n    }\n\n    return pill;\n  }\n\n  function applyState() {\n    // Always hide any external overlay pill if present\n    var overlay = document.getElementById(\"ops-status-pill\");\n    if (overlay) {\n      overlay.style.display = \"none\";\n    }\n\n    var pill = ensurePill();\n    if (!pill) return;\n\n    var hasHeartbeat = (typeof window.lastOpsHeartbeat === \"number\");\n\n    var label = hasHeartbeat ? \"OPS: Online\"  : \"OPS: Unknown\";\n    var cls   = hasHeartbeat ? \"ops-pill-online\" : \"ops-pill-unknown\";\n\n    pill.classList.remove(\n      \"ops-pill-unknown\",\n      \"ops-pill-online\",\n      \"ops-pill-stale\",\n      \"ops-pill-error\"\n    );\n    pill.classList.add(cls);\n    pill.textContent = label;\n  }\n\n  applyState();\n  setInterval(applyState, POLL_INTERVAL_MS);\n})();\n", "/**\n * Tasks Widget (stable, no SSE)\n * - GET /api/tasks\n * - POST /api/complete-task\n * - No optimistic removal (prevents list blinking)\n */\n(() => {\n  const API = {\n    list: \"/api/tasks\",\n    complete: \"/api/complete-task\",\n  };\n\n  const SELECTORS = [\n    \"#tasks-widget\",\n    \"#tasksWidget\",\n    \"[data-tasks-widget]\",\n    \"[data-widget='tasks']\",\n  ];\n\n  const state = {\n    tasks: [],\n    loading: false,\n    lastError: null,\n    inflightComplete: new Set(),\n  };\n\n  function $(sel, root = document) {\n    return root.querySelector(sel);\n  }\n\n  function findMount() {\n    for (const sel of SELECTORS) {\n      const el = $(sel);\n      if (el) return el;\n    }\n    return null;\n  }\n\n  function esc(s) {\n    return String(s ?? \"\")\n      .replaceAll(\"&\", \"&amp;\")\n      .replaceAll(\"<\", \"&lt;\")\n      .replaceAll(\">\", \"&gt;\")\n      .replaceAll('\"', \"&quot;\")\n      .replaceAll(\"'\", \"&#39;\");\n  }\n\n  async function apiJson(url, opts = {}) {\n    const res = await fetch(url, {\n      method: opts.method || \"GET\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: opts.body ? JSON.stringify(opts.body) : undefined,\n    });\n    const json = await res.json();\n    if (!res.ok) throw new Error(json?.error || \"Request failed\");\n    return json;\n  }\n\n  async function fetchTasks() {\n    state.loading = true;\n    render();\n    try {\n      const data = await apiJson(API.list);\n      state.tasks = (data.tasks || []).map(t => ({\n        id: String(t.id),\n        title: t.title || \"\",\n        status: t.status || \"\",\n      }));\n    } catch (e) {\n      state.lastError = e.message;\n    } finally {\n      state.loading = false;\n      render();\n    }\n  }\n\n  async function completeTask(taskId) {\n    if (state.inflightComplete.has(taskId)) return;\n    state.inflightComplete.add(taskId);\n    render();\n\n    try {\n      await apiJson(API.complete, {\n        method: \"POST\",\n        body: { taskId },\n      });\n    } catch (e) {\n      state.lastError = e.message;\n    } finally {\n      state.inflightComplete.delete(taskId);\n      await fetchTasks();\n    }\n  }\n\n  function render() {\n    const mount = findMount();\n    if (!mount) return;\n\n    mount.innerHTML = `\n      <div>\n        \n        ${state.lastError ? `<div style=\"color:red\">${esc(state.lastError)}</div>` : \"\"}\n        <div>\n          ${state.tasks.map(t => `\n            <div style=\"display:flex;justify-content:space-between;gap:8px\">\n              <span>${esc(t.title)}</span>\n              ${\n                ([\"complete\",\"completed\",\"done\"].includes(String(t.status||\"\").toLowerCase()))\n                  ? `<span style=\"opacity:.5;font-size:12px\">Completed</span>`\n                  : `<button data-id=\"${t.id}\">Complete</button>`\n              }\n            </div>\n          `).join(\"\")}\n        </div>\n      </div>\n    `;\n\n    mount.querySelectorAll(\"button[data-id]\").forEach(btn => {\n      btn.onclick = () => completeTask(btn.dataset.id);\n    });\n  }\n\n  document.addEventListener(\"DOMContentLoaded\", fetchTasks);\n\n  // Phase22: SSE-driven refresh (ignore heartbeats)\n  window.addEventListener(\"mb.task.event\", (e) => {\n    const k = String(e?.detail?.kind || e?.detail?.type || \"\");\n    if (k === \"heartbeat\") return;\n    fetchTasks();\n  });\n\n// Phase22: SSE-driven refresh\n  window.addEventListener(\"mb.task.event\", () => { fetchTasks(); });\n\n// Auto-refresh (no SSE): keep widget feeling live\n  setInterval(() => { fetchTasks(); }, 5000);\n\n})();\n", "(function () {\n  function log(msg) {\n    console.log(\"[matilda-chat]\", msg);\n  }\n\n  function appendMessage(transcriptEl, sender, text) {\n    if (!transcriptEl) return;\n    var line = document.createElement(\"p\");\n    line.className = \"mb-1 text-sm\";\n    var label = sender ? sender + \": \" : \"\";\n    line.textContent = label + text;\n    transcriptEl.appendChild(line);\n    transcriptEl.scrollTop = transcriptEl.scrollHeight;\n  }\n\n  function setSendingState(sendBtn, input, isSending) {\n    if (sendBtn) {\n      sendBtn.disabled = isSending;\n      sendBtn.classList.toggle(\"opacity-60\", isSending);\n      sendBtn.textContent = isSending ? \"Sending...\" : \"Send\";\n    }\n    if (input) {\n      input.disabled = isSending;\n    }\n  }\n\n  async function wireChat() {\n    var root = document.getElementById(\"matilda-chat-root\");\n    if (!root) {\n      log(\"No #matilda-chat-root found; skipping wiring.\");\n      return;\n    }\n\n    var transcript = document.getElementById(\"matilda-chat-transcript\");\n    var input = document.getElementById(\"matilda-chat-input\");\n    var sendBtn = document.getElementById(\"matilda-chat-send\");\n\n    if (!transcript || !input || !sendBtn) {\n      log(\"Missing one or more Matilda chat elements; aborting wiring.\");\n      return;\n    }\n\n    function safeTrim(value) {\n      return (value || \"\").toString().trim();\n    }\n\n    async function handleSend() {\n      var message = safeTrim(input.value);\n      if (!message) return;\n\n      appendMessage(transcript, \"You\", message);\n      input.value = \"\";\n      setSendingState(sendBtn, input, true);\n\n      try {\n        var res = await fetch(\"/api/chat\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ message: message, agent: \"matilda\" }),\n        });\n\n        if (!res.ok) {\n          appendMessage(\n            transcript,\n            \"Matilda\",\n            \"(error talking to /api/chat)\"\n          );\n          return;\n        }\n\n        var data = await res.json();\n        var reply =\n          (data && (data.reply || data.message || data.response)) ||\n          \"(no reply)\";\n        appendMessage(transcript, \"Matilda\", reply);\n      } catch (err) {\n        console.error(err);\n        appendMessage(transcript, \"Matilda\", \"(network error)\");\n      } finally {\n        setSendingState(sendBtn, input, false);\n      }\n    }\n\n    sendBtn.addEventListener(\"click\", handleSend);\n\n    var quickBtn = document.getElementById(\"matilda-chat-quick-check\");\n    if (quickBtn) {\n      quickBtn.addEventListener(\"click\", function () {\n        input.value = \"Quick systems check from dashboard Phase 11.4.\";\n        handleSend();\n      });\n    }\n\n    input.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Enter\" && !e.shiftKey) {\n        e.preventDefault();\n        handleSend();\n      }\n    });\n\n    log(\"Matilda chat wiring complete.\");\n  }\n\n  document.addEventListener(\"DOMContentLoaded\", wireChat);\n})();\n", "(() => {\n  const SSE_URL = \"/events/task-events\";\n\n  const PANEL_ID = \"mb-task-events-panel\";\n  const FEED_ID = \"mb-task-events-feed\";\n  const COUNTS_ID = \"mb-task-events-counts\";\n  const ANCHOR_ID = \"mb-task-events-panel-anchor\";\n\n  function mountRoot() {\n    const anchor = document.getElementById(ANCHOR_ID);\n    if (anchor) return anchor;\n    return document.body;\n  }\n\n  function ensurePanel() {\n    if (document.getElementById(PANEL_ID)) return;\n\n    const root = mountRoot();\n\n    const panel = document.createElement(\"div\");\n    panel.id = PANEL_ID;\n\n    // If anchored, behave like an in-page card; otherwise float.\n    const anchored = root && root.id === ANCHOR_ID;\n\n    panel.style.width = anchored ? \"100%\" : \"360px\";\n    panel.style.maxWidth = anchored ? \"100%\" : \"calc(100vw - 24px)\";\n    panel.style.maxHeight = anchored ? \"260px\" : \"40vh\";\n    panel.style.overflow = \"hidden\";\n    panel.style.zIndex = \"9999\";\n    panel.style.border = \"1px solid rgba(255,255,255,0.12)\";\n    panel.style.borderRadius = \"14px\";\n    panel.style.background = \"rgba(10,10,14,0.92)\";\n    panel.style.backdropFilter = \"blur(10px)\";\n    panel.style.boxShadow = \"0 10px 30px rgba(0,0,0,0.35)\";\n    panel.style.color = \"rgba(255,255,255,0.92)\";\n    panel.style.fontFamily =\n      \"ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace\";\n\n    if (!anchored) {\n      panel.style.position = \"fixed\";\n      panel.style.right = \"12px\";\n      panel.style.bottom = \"12px\";\n    } else {\n      panel.style.marginTop = \"12px\";\n    }\n\n    const header = document.createElement(\"div\");\n    header.style.display = \"flex\";\n    header.style.alignItems = \"center\";\n    header.style.justifyContent = \"space-between\";\n    header.style.gap = \"8px\";\n    header.style.padding = \"10px 12px\";\n    header.style.borderBottom = \"1px solid rgba(255,255,255,0.10)\";\n\n    const title = document.createElement(\"div\");\n    title.textContent = \"TASK EVENTS (live)\";\n    title.style.fontSize = \"12px\";\n    title.style.letterSpacing = \"0.08em\";\n    title.style.opacity = \"0.9\";\n\n    const right = document.createElement(\"div\");\n    right.style.display = \"flex\";\n    right.style.alignItems = \"center\";\n    right.style.gap = \"10px\";\n\n    const counts = document.createElement(\"div\");\n    counts.id = COUNTS_ID;\n    counts.textContent = \"created:0  completed:0  failed:0\";\n    counts.style.fontSize = \"11px\";\n    counts.style.opacity = \"0.85\";\n\n    const dot = document.createElement(\"span\");\n    dot.setAttribute(\"aria-label\", \"task-events connection\");\n    dot.title = \"task-events connection\";\n    dot.style.display = \"inline-block\";\n    dot.style.width = \"10px\";\n    dot.style.height = \"10px\";\n    dot.style.borderRadius = \"999px\";\n    dot.style.background = \"rgba(255,255,255,0.25)\";\n    dot.style.boxShadow = \"0 0 0 2px rgba(255,255,255,0.08) inset\";\n\n    const btn = document.createElement(\"button\");\n    btn.type = \"button\";\n    btn.textContent = \"\u00D7\";\n    btn.title = \"hide\";\n    btn.style.cursor = \"pointer\";\n    btn.style.border = \"1px solid rgba(255,255,255,0.14)\";\n    btn.style.background = \"transparent\";\n    btn.style.color = \"rgba(255,255,255,0.85)\";\n    btn.style.borderRadius = \"10px\";\n    btn.style.width = \"28px\";\n    btn.style.height = \"24px\";\n    btn.style.lineHeight = \"22px\";\n    btn.style.fontSize = \"14px\";\n    btn.onclick = () => panel.remove();\n\n    right.appendChild(dot);\n    right.appendChild(counts);\n    right.appendChild(btn);\n\n    header.appendChild(title);\n    header.appendChild(right);\n\n    const feed = document.createElement(\"div\");\n    feed.id = FEED_ID;\n    feed.style.padding = \"10px 12px\";\n    feed.style.overflow = \"auto\";\n    feed.style.maxHeight = anchored ? \"200px\" : \"calc(40vh - 46px)\";\n\n    panel.appendChild(header);\n    panel.appendChild(feed);\n\n    root.appendChild(panel);\n\n    window.__MB_TASK_EVENTS_PANEL = { dot, feed, counts };\n    console.log(\"[phase22] task-events panel mounted (anchored=%s)\", anchored);\n  }\n\n  function setDot(state) {\n    ensurePanel();\n    const dot = window.__MB_TASK_EVENTS_PANEL?.dot;\n    if (!dot) return;\n    if (state === \"open\") dot.style.background = \"rgba(80,200,120,0.85)\";\n    else if (state === \"error\") dot.style.background = \"rgba(240,90,90,0.85)\";\n    else dot.style.background = \"rgba(255,255,255,0.25)\";\n  }\n\n  const seen = new Set();\n  const tally = { created: 0, completed: 0, failed: 0 };\n\n  function bumpCounts(kind) {\n    if (kind === \"task.created\") tally.created += 1;\n    if (kind === \"task.completed\") tally.completed += 1;\n    if (kind === \"task.failed\") tally.failed += 1;\n\n    const el = document.getElementById(COUNTS_ID);\n    if (el) el.textContent = `created:${tally.created}  completed:${tally.completed}  failed:${tally.failed}`;\n  }\n\n  function formatLine(ev, fallbackKind) {\n    const ts = typeof ev.ts === \"number\" ? new Date(ev.ts).toISOString() : new Date().toISOString();\n    const tid = ev.task_id ?? ev.id ?? ev.taskId ?? \"unknown\";\n    const run = ev.run_id ?? ev.runId ?? \"\";\n    const msg = ev.msg ?? ev.message ?? \"\";\n    const extras = [];\n    if (run) extras.push(`run=${run}`);\n    if (ev.actor) extras.push(`actor=${ev.actor}`);\n    if (ev.status) extras.push(`status=${ev.status}`);\n    if (typeof ev.cursor === \"number\") extras.push(`cursor=${ev.cursor}`);\n    const extraStr = extras.length ? ` (${extras.join(\" \")})` : \"\";\n    return `${ts}  ${(ev.kind ?? fallbackKind ?? \"event\")}  task=${tid}${extraStr}${msg ? \" \u2014 \" + msg : \"\"}`;\n  }\n\n  function appendLine(text, kind) {\n    ensurePanel();\n    const feed = document.getElementById(FEED_ID);\n    if (!feed) return;\n\n    const row = document.createElement(\"div\");\n    row.style.whiteSpace = \"pre-wrap\";\n    row.style.wordBreak = \"break-word\";\n    row.style.fontSize = \"11px\";\n    row.style.lineHeight = \"1.35\";\n    row.style.padding = \"6px 8px\";\n    row.style.border = \"1px solid rgba(255,255,255,0.10)\";\n    row.style.borderRadius = \"12px\";\n    row.style.marginBottom = \"8px\";\n    row.style.background = \"rgba(255,255,255,0.03)\";\n\n    if (kind === \"task.completed\") row.style.borderColor = \"rgba(80,200,120,0.35)\";\n    if (kind === \"task.failed\") row.style.borderColor = \"rgba(240,90,90,0.35)\";\n    if (kind === \"heartbeat\") row.style.opacity = \"0.65\";\n\n    row.textContent = text;\n    feed.prepend(row);\n\n    const children = Array.from(feed.children);\n    if (children.length > 60) {\n      for (let i = 60; i < children.length; i++) children[i].remove();\n    }\n  }\n\n  function dispatchWindowEvent(ev) {\n    try { window.dispatchEvent(new CustomEvent(\"mb.task.event\", { detail: ev })); } catch {}\n  }\n\n  function parseMaybeJSON(raw) {\n    try { return JSON.parse(raw); } catch { return null; }\n  }\n\n  function handleFrame(eventName, rawData) {\n    const data = typeof rawData === \"string\" ? parseMaybeJSON(rawData) : rawData;\n    const ev = (data && typeof data === \"object\") ? data : { kind: eventName, raw: rawData };\n\n      // Phase22 normalization:\n      // server sends event: task.event with payload { type:\"task.created|task.completed|task.failed\", taskId:\"...\" }\n      if (eventName === \"task.event\") {\n        if (!ev.kind && ev.type) ev.kind = ev.type;\n        if (ev.kind === \"task.event\" && ev.type) ev.kind = ev.type;\n        if (ev.task_id == null && ev.taskId != null) ev.task_id = ev.taskId;\n        if (ev.run_id == null && ev.runId != null) ev.run_id = ev.runId;\n      }\n\n    if (!ev.kind) ev.kind = eventName;\n\n    const key = `${eventName}|${ev.kind}|${ev.ts ?? \"\"}|${ev.task_id ?? ev.id ?? \"\"}|${ev.run_id ?? \"\"}|${ev.cursor ?? \"\"}`;\n    if (seen.has(key)) return;\n    seen.add(key);\n\n    if (ev.kind === \"task.created\" || ev.kind === \"task.completed\" || ev.kind === \"task.failed\") {\n      bumpCounts(String(ev.kind));\n    }\n\n    appendLine(formatLine(ev, eventName), String(ev.kind ?? eventName));\n    dispatchWindowEvent(ev);\n  }\n\n  let es = null;\n  let attempt = 0;\n\n  function connect() {\n    ensurePanel();\n\n    if (es) {\n      try { es.close(); } catch {}\n      es = null;\n    }\n\n    const url = SSE_URL;\n    es = new EventSource(url);\n\n    es.onopen = () => {\n      attempt = 0;\n      setDot(\"open\");\n      appendLine(`${new Date().toISOString()}  sse.open  url=${url}`, \"sse.open\");\n      console.log(\"[phase22] task-events SSE open\", url);\n    };\n\n    es.onerror = () => {\n      setDot(\"error\");\n      try { es.close(); } catch {}\n      es = null;\n\n      attempt += 1;\n      const delay = Math.min(15000, 500 * Math.pow(2, Math.min(6, attempt)));\n      appendLine(`${new Date().toISOString()}  sse.error  reconnect_in=${delay}ms`, \"sse.error\");\n      console.log(\"[phase22] task-events SSE error; reconnect in\", delay);\n      setTimeout(connect, delay);\n    };\n\n    es.onmessage = (msg) => handleFrame(\"message\", msg.data);\n\n    const names = [\n      \"hello\",\n      \"heartbeat\",\n      \"task.event\",\n      \"task.created\",\n      \"task.completed\",\n      \"task.failed\",\n      \"task.updated\",\n      \"task.status\",\n    ];\n    for (const name of names) {\n      es.addEventListener(name, (e) => handleFrame(name, e.data));\n    }\n  }\n\n  function boot() {\n    connect();\n    // Guard: if something removes the panel, re-mount + reconnect.\n    setInterval(() => {\n      if (!document.getElementById(PANEL_ID)) {\n        try { connect(); } catch {}\n      }\n    }, 2000);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", boot, { once: true });\n  } else {\n    boot();\n  }\n\n  window.__MB_TASK_EVENTS = { url: SSE_URL, reconnect: () => connect() };\n})();\n", "(() => {\n  // Phase 22: bind task-events SSE -> Task Delegation + status UI (best-effort)\n\n  const TASK_EVENT_NAME = \"mb.task.event\";\n  const tasks = new Map();\n\n  const STATUS_CLASS = {\n    queued: \"task-status-queued\",\n    done: \"task-status-done\",\n    failed: \"task-status-failed\",\n  };\n\n  function normStatus(s) {\n    const v = String(s ?? \"\").toLowerCase();\n    if (v === \"queued\" || v === \"pending\") return \"queued\";\n    if (v === \"done\" || v === \"complete\" || v === \"completed\") return \"done\";\n    if (v === \"failed\" || v === \"error\") return \"failed\";\n    return v || \"unknown\";\n  }\n\n  function pluckId(ev) {\n    return ev?.task_id ?? ev?.taskId ?? ev?.id ?? ev?.task?.id ?? null;\n  }\n\n  function pluckTask(ev) {\n    const t = ev?.task && typeof ev.task === \"object\" ? ev.task : null;\n    const id = pluckId(ev);\n    const status =\n      ev?.status ??\n      ev?.payload?.status ??\n      t?.status ??\n      (ev?.kind === \"task.created\" ? \"queued\" : null);\n\n    return {\n      id: id != null ? String(id) : null,\n      status: status != null ? normStatus(status) : null,\n      title: t?.title ?? ev?.title ?? null,\n      agent: t?.agent ?? ev?.agent ?? null,\n      error: ev?.error ?? ev?.payload?.error ?? t?.error ?? null,\n      updated_at: t?.updated_at ?? ev?.ts ?? Date.now(),\n    };\n  }\n\n  function setStatusOnNode(node, status) {\n    if (!node) return;\n    const s = normStatus(status);\n    node.setAttribute(\"data-task-status\", s);\n    node.classList?.remove(...Object.values(STATUS_CLASS));\n    if (STATUS_CLASS[s]) node.classList?.add(STATUS_CLASS[s]);\n\n    const sub =\n      node.querySelector?.(\"[data-task-field='status']\") ||\n      node.querySelector?.(\".task-status\") ||\n      node.querySelector?.(\".status\") ||\n      null;\n    if (sub) sub.textContent = s;\n  }\n\n  function updateTaskRowUI(task) {\n    if (!task?.id) return;\n    const id = String(task.id);\n    const nodes = [\n      document.getElementById(`task-${id}`),\n      document.getElementById(`task_${id}`),\n      document.querySelector?.(`[data-task-id=\"${CSS.escape(id)}\"]`),\n      document.querySelector?.(`[data-taskid=\"${CSS.escape(id)}\"]`),\n    ].filter(Boolean);\n\n    for (const n of nodes) setStatusOnNode(n, task.status);\n  }\n\n  function updateCountersUI() {\n    let queued = 0, done = 0, failed = 0;\n    for (const t of tasks.values()) {\n      const s = normStatus(t.status);\n      if (s === \"queued\") queued++;\n      else if (s === \"done\") done++;\n      else if (s === \"failed\") failed++;\n    }\n\n    const map = [\n      [\"queued\", queued],\n      [\"done\", done],\n      [\"failed\", failed],\n    ];\n\n    for (const [k, v] of map) {\n      const el =\n        document.getElementById(`task-count-${k}`) ||\n        document.getElementById(`tasks-${k}-count`) ||\n        document.querySelector?.(`[data-task-count=\"${k}\"]`) ||\n        null;\n      if (el) el.textContent = String(v);\n    }\n  }\n\n  function ingestTask(task) {\n    if (!task?.id) return;\n    const id = String(task.id);\n    const prev = tasks.get(id) || {};\n    const next = { ...prev, ...task, id, status: task.status ?? prev.status };\n    tasks.set(id, next);\n    updateTaskRowUI(next);\n    updateCountersUI();\n  }\n\n  function onTaskEvent(ev) {\n    const t = pluckTask(ev);\n    if (!t.id && ev?.kind) {\n      if (ev.kind === \"task.completed\") t.status = \"done\";\n      if (ev.kind === \"task.failed\") t.status = \"failed\";\n    }\n    if (t.id) ingestTask(t);\n  }\n\n  function attach() {\n    if (window.__PHASE22_TASK_UI_BOUND) return;\n    window.__PHASE22_TASK_UI_BOUND = true;\n\n    window.addEventListener(TASK_EVENT_NAME, (e) => {\n      try { if (window.__UI_DEBUG || window.__PHASE22_DEBUG) if (window.__UI_DEBUG || window.__PHASE22_DEBUG) console.log(\"[phase22] mb.task.event\", e.detail); onTaskEvent(e.detail); } catch {}\n    });\n\n    window.__PHASE22_TASK_UI = { tasks }; console.log(\"[phase22] bindings attached\");\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", attach, { once: true });\n  } else {\n    attach();\n  }\n})();\n", "import \"./sse-heartbeat-shim.js\";\nimport \"./heartbeat-stale-indicator.js\";\nimport \"./task-events-sse-listener.js\";\n// Phase 11 \u2013 Unified dashboard bundle entrypoint\n\n// Core dashboard status + tiles\nimport \"./dashboard-status.js\";\n\n// Phase 15/16 boundary: disable optional SSE (OPS + Reflections) until backends exist\nif (typeof window !== \"undefined\" && typeof window.__DISABLE_OPTIONAL_SSE === \"undefined\") {\n  window.__DISABLE_OPTIONAL_SSE = false;\n}\n\nimport \"./agent-status-row.js\";\n\n// OPS / PM2 status + SSE wiring\nimport \"./dashboard-broadcast.js\";\nimport \"./ops-status-widget.js\";\nimport \"./ops-globals-bridge.js\";\nimport \"./ops-pill-state.js\";\nimport \"./dashboard-tasks-widget.js\";\n\n// Matilda chat console wiring\nimport \"./matilda-chat-console.js\";\n\n// TEMP: dashboard graph disabled until canvas is present on all pages\n// import \"./dashboard-graph.js\";\n\n\n// Phase 22: task-events live UI\nimport \"./task-events-sse-client.js\";\nimport \"./phase22_task_delegation_live_bindings.js\";\n"],
- 
- ## 3) Optimistic/inference patterns
- public/bundle.js:1152:    function formatLine(ev, fallbackKind) {
- public/bundle.js:1163:      return `${ts}  ${ev.kind ?? fallbackKind ?? "event"}  task=${tid}${extraStr}${msg ? " \u2014 " + msg : ""}`;
- public/bundle-core.js:1366:      _fallback: false,
- public/bundle-core.js:1381:      _fallback: "animation"
- public/bundle-core.js:1559:      _fallback: false,
- public/bundle-core.js:1564:      _fallback: "scale"
- public/bundle-core.js:1681:      _fallback: "interaction"
- public/bundle-core.js:2051:  function toFont(options, fallback) {
- public/bundle-core.js:2053:    fallback = fallback || defaults.font;
- public/bundle-core.js:2054:    let size = valueOrDefault(options.size, fallback.size);
- public/bundle-core.js:2058:    let style = valueOrDefault(options.style, fallback.style);
- public/bundle-core.js:2064:      family: valueOrDefault(options.family, fallback.family),
- public/bundle-core.js:2065:      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
- public/bundle-core.js:2068:      weight: valueOrDefault(options.weight, fallback.weight),
- public/bundle-core.js:2112:  ], rootScopes, fallback, getTarget = () => scopes[0]) {
- public/bundle-core.js:2114:    if (typeof fallback === "undefined") {
- public/bundle-core.js:2115:      fallback = _resolve("_fallback", scopes);
- public/bundle-core.js:2122:      _fallback: fallback,
- public/bundle-core.js:2127:      ], prefixes, finalRootScopes, fallback)
- public/bundle-core.js:2310:  function resolveFallback(fallback, prop, value) {
- public/bundle-core.js:2311:    return isFunction(fallback) ? fallback(prop, value) : fallback;
- public/bundle-core.js:2319:        const fallback = resolveFallback(scope._fallback, key, value);
- public/bundle-core.js:2320:        if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
- public/bundle-core.js:2321:          return fallback;
- public/bundle-core.js:2331:    const fallback = resolveFallback(resolver._fallback, prop, value);
- public/bundle-core.js:2338:    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
- public/bundle-core.js:2342:    if (typeof fallback !== "undefined" && fallback !== prop) {
- public/bundle-core.js:2343:      key = addScopesFromKey(set2, allScopes, fallback, key, value);
- public/bundle-core.js:2350:    ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
- public/bundle-core.js:2352:  function addScopesFromKey(set2, allScopes, key, fallback, item) {
- public/bundle-core.js:2354:      key = addScopes(set2, allScopes, key, fallback, item);
- public/bundle-core.js:6833:  function getTitleHeight(options, fallback) {
- public/bundle-core.js:6837:    const font = toFont(options.font, fallback);
- public/bundle-core.js:13060:        _fallback: false
- public/bundle-core.js:13063:        _fallback: "animation"
- public/bundle-core.js:13912:        _fallback: "grid"
- public/bundle.js.map:4:  "sourcesContent": ["/**\n * Phase 16 \u2013 Shared Heartbeat Bus (OPS + Tasks)\n *\n * Wrap EventSource so connection + any SSE message updates a normalized heartbeat store.\n *\n * Exposes:\n *   window.__HB = { record(kind, ts), get(kind), snapshot() }\n *\n * kind: \"ops\" | \"tasks\" | \"reflections\" | \"unknown\"\n */\n(function () {\n  const w = window;\n\n  const STORE_KEY = \"__HB\";\n  if (!w[STORE_KEY]) {\n    const state = { ops: null, tasks: null, reflections: null, unknown: null };\n    w[STORE_KEY] = {\n      record(kind, ts) {\n        const k = Object.prototype.hasOwnProperty.call(state, kind) ? kind : \"unknown\";\n        state[k] = typeof ts === \"number\" ? ts : Date.now();\n        return state[k];\n      },\n      get(kind) {\n        const k = Object.prototype.hasOwnProperty.call(state, kind) ? kind : \"unknown\";\n        return state[k];\n      },\n      snapshot() {\n        return { ...state };\n      },\n    };\n  }\n\n  const NativeEventSource = w.EventSource;\n  if (!NativeEventSource || NativeEventSource.__hbWrapped) return;\n\n  function classify(url) {\n    const u = String(url || \"\");\n    if (u.includes(\"/events/ops\")) return \"ops\";\n    if (u.includes(\"/events/tasks\")) return \"tasks\";\n    if (u.includes(\"/events/reflections\")) return \"reflections\";\n    return \"unknown\";\n  }\n\n  function HeartbeatEventSource(url, eventSourceInitDict) {\n    const kind = classify(url);\n\n    // Record immediately on connection attempt so \"connected but quiet\" still looks alive.\n    try { w[STORE_KEY].record(kind, Date.now()); } catch (_) {}\n\n    const es = new NativeEventSource(url, eventSourceInitDict);\n\n    const update = () => {\n      try { w[STORE_KEY].record(kind, Date.now()); } catch (_) {}\n    };\n\n    // Update heartbeat when the connection opens (most reliable for \"alive\").\n    try { es.addEventListener(\"open\", update); } catch (_) {}\n\n    // Update heartbeat on any message for this stream.\n    try { es.addEventListener(\"message\", update); } catch (_) {}\n\n    // Also wrap onmessage if assigned later.\n    let _onmessage = null;\n    Object.defineProperty(es, \"onmessage\", {\n      get() { return _onmessage; },\n      set(fn) {\n        _onmessage = function (ev) {\n          update();\n          if (typeof fn === \"function\") return fn.call(es, ev);\n        };\n      },\n      configurable: true,\n    });\n\n    // Update heartbeat when errors occur too (helps show \"something happened\" vs silence).\n    try { es.addEventListener(\"error\", update); } catch (_) {}\n\n    return es;\n  }\n\n  HeartbeatEventSource.prototype = NativeEventSource.prototype;\n  HeartbeatEventSource.__hbWrapped = true;\n\n  w.EventSource = HeartbeatEventSource;\n})();\n", "/**\n * Phase 16 \u2013 Heartbeat stale-state indicator (non-intrusive)\n *\n * Reads window.__HB (from sse-heartbeat-shim) and updates a tiny badge.\n * - Adds a badge to the top-right corner of the dashboard.\n * - Shows OK when both OPS+Tasks have recent heartbeats.\n * - Shows STALE when either stream is missing or old.\n *\n * No coupling to widget internals. Safe to remove.\n */\n(function () {\n  const w = window;\n  const HB = w.__HB;\n\n  function now() {\n    return Date.now();\n  }\n\n  function ms(n) {\n    return Math.max(0, Number(n) || 0);\n  }\n\n  // Consider heartbeats stale after this many ms.\n  const STALE_MS = 15000;\n\n  function fmtAge(ts) {\n    if (!ts) return \"\u2014\";\n    const s = Math.floor((now() - ts) / 1000);\n    return s <= 0 ? \"0s\" : `${s}s`;\n  }\n\n  function ensureBadge() {\n    let el = document.getElementById(\"hb-badge\");\n    if (el) return el;\n\n    el = document.createElement(\"div\");\n    el.id = \"hb-badge\";\n    el.setAttribute(\"role\", \"status\");\n    el.style.position = \"fixed\";\n    el.style.top = \"12px\";\n    el.style.right = \"12px\";\n    el.style.zIndex = \"9999\";\n    el.style.fontFamily = \"ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial\";\n    el.style.fontSize = \"12px\";\n    el.style.padding = \"6px 10px\";\n    el.style.borderRadius = \"999px\";\n    el.style.border = \"1px solid rgba(255,255,255,0.14)\";\n    el.style.background = \"rgba(0,0,0,0.55)\";\n    el.style.backdropFilter = \"blur(6px)\";\n    el.style.webkitBackdropFilter = \"blur(6px)\";\n    el.style.color = \"rgba(255,255,255,0.92)\";\n    el.style.boxShadow = \"0 8px 18px rgba(0,0,0,0.35)\";\n    el.style.userSelect = \"none\";\n    el.style.cursor = \"default\";\n    document.body.appendChild(el);\n    return el;\n  }\n\n  function setState(el, ok) {\n    // No colors specified by instruction in other contexts; keep neutral text-only signal.\n    // We\u2019ll use symbols instead of colored fills.\n    el.textContent = ok\n      ? `HB \u2713 (ops ${fmtAge(HB && HB.get(\"ops\"))}, tasks ${fmtAge(HB && HB.get(\"tasks\"))})`\n      : `HB ! (ops ${fmtAge(HB && HB.get(\"ops\"))}, tasks ${fmtAge(HB && HB.get(\"tasks\"))})`;\n  }\n\n  function tick() {\n    const el = ensureBadge();\n\n    if (!HB || typeof HB.get !== \"function\") {\n      el.textContent = \"HB ? (shim not loaded)\";\n      return;\n    }\n\n    const ops = HB.get(\"ops\");\n    const tasks = HB.get(\"tasks\");\n\n    const opsOk = !!ops && ms(now() - ops) <= STALE_MS;\n    const tasksOk = !!tasks && ms(now() - tasks) <= STALE_MS;\n\n    setState(el, opsOk && tasksOk);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      tick();\n      setInterval(tick, 1000);\n    });\n  } else {\n    tick();\n    setInterval(tick, 1000);\n  }\n})();\n", "/**\n * Phase 21: Task Events SSE listener\n * - Parallel to ops/reflections (does not modify their ownership)\n * - Opens EventSource(\"/events/task-events\")\n * - Buffers events on window.__TASK_EVENTS_FEED and emits DOM event \"task-events:append\"\n * - Tiny debug panel is ALWAYS clickable (collapsed by default)\n *   - Auto-expands when window.__UI_DEBUG or window.__PHASE21_SHOW_TASK_EVENTS is true\n * - Exposes window.__TASK_EVENTS snapshot for quick inspection\n */\n(function () {\n  const URL = \"/events/task-events\";\n  const MAX_ITEMS = 200;\n\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") return;\n  if (window.__TASK_EVENTS_SSE_INITED) return;\n  window.__TASK_EVENTS_SSE_INITED = true;\n\n  function nowIso() {\n    try { return new Date().toISOString(); } catch { return String(Date.now()); }\n  }\n\n  function ensureBuffer() {\n    if (!window.__TASK_EVENTS_FEED) window.__TASK_EVENTS_FEED = [];\n    return window.__TASK_EVENTS_FEED;\n  }\n\n  function ensureSnapshot() {\n    if (!window.__TASK_EVENTS) {\n      window.__TASK_EVENTS = {\n        url: URL,\n        connected: false,\n        lastAt: 0,\n        lastEvent: null,\n        cursor: null,\n        readyState: null,\n      };\n    }\n    return window.__TASK_EVENTS;\n  }\n\n  function pushItem(item) {\n    const buf = ensureBuffer();\n    buf.push(item);\n    if (buf.length > MAX_ITEMS) buf.splice(0, buf.length - MAX_ITEMS);\n\n    const snap = ensureSnapshot();\n    snap.lastAt = item.ts || Date.now();\n    snap.lastEvent = item.event || item.kind || null;\n    if (item?.data && typeof item.data === \"object\" && \"cursor\" in item.data) {\n      snap.cursor = item.data.cursor ?? snap.cursor;\n    }\n    try { snap.readyState = window.__taskEventsES?.readyState ?? null; } catch {}\n\n    try {\n      window.dispatchEvent(new CustomEvent(\"task-events:append\", { detail: item }));\n    } catch {}\n  }\n\n  function safeJson(s) {\n    try { return JSON.parse(s); } catch { return null; }\n  }\n\n  function ensureMiniPanel() {\n    if (document.getElementById(\"task-events-log\")) return;\n\n    const wrap = document.createElement(\"div\");\n    wrap.id = \"task-events-log\";\n    wrap.style.position = \"fixed\";\n    wrap.style.right = \"14px\";\n    wrap.style.bottom = \"14px\";\n    wrap.style.width = \"440px\";\n    wrap.style.maxHeight = \"240px\";\n    wrap.style.overflow = \"hidden\"; // body scrolls, header stays\n    wrap.style.padding = \"10px 12px\";\n    wrap.style.borderRadius = \"12px\";\n    wrap.style.fontFamily = \"ui-monospace, Menlo, Monaco, Consolas, monospace\";\n    wrap.style.fontSize = \"12px\";\n    wrap.style.lineHeight = \"1.35\";\n    wrap.style.zIndex = \"99999\";\n    wrap.style.background = \"rgba(10,10,14,0.72)\";\n    wrap.style.border = \"1px solid rgba(255,255,255,0.12)\";\n    wrap.style.boxShadow = \"0 10px 24px rgba(0,0,0,0.35)\";\n    wrap.style.backdropFilter = \"blur(6px)\";\n    wrap.style.display = \"block\"; // ALWAYS clickable\n\n    const hdr = document.createElement(\"div\");\n    hdr.style.display = \"flex\";\n    hdr.style.alignItems = \"center\";\n    hdr.style.justifyContent = \"space-between\";\n    hdr.style.gap = \"10px\";\n    hdr.style.marginBottom = \"8px\";\n\n    const title = document.createElement(\"div\");\n    title.id = \"task-events-log-title\";\n    title.textContent = \"TASK EVENTS \u00B7 disconnected\";\n    title.style.letterSpacing = \"0.12em\";\n    title.style.fontWeight = \"700\";\n    title.style.opacity = \"0.9\";\n\n    const btn = document.createElement(\"button\");\n    btn.type = \"button\";\n    btn.textContent = \"expand\";\n    btn.style.cursor = \"pointer\";\n    btn.style.border = \"1px solid rgba(255,255,255,0.15)\";\n    btn.style.background = \"rgba(255,255,255,0.08)\";\n    btn.style.color = \"rgba(255,255,255,0.9)\";\n    btn.style.borderRadius = \"10px\";\n    btn.style.padding = \"4px 8px\";\n    btn.style.fontSize = \"12px\";\n\n    const body = document.createElement(\"div\");\n    body.id = \"task-events-log-body\";\n    body.style.maxHeight = \"190px\";\n    body.style.overflow = \"auto\";\n    body.style.display = \"none\"; // collapsed by default\n\n    btn.onclick = () => {\n      const on = body.style.display === \"none\";\n      body.style.display = on ? \"block\" : \"none\";\n      btn.textContent = on ? \"collapse\" : \"expand\";\n    };\n\n    hdr.appendChild(title);\n    hdr.appendChild(btn);\n\n    wrap.appendChild(hdr);\n    wrap.appendChild(body);\n    document.body.appendChild(wrap);\n\n    // Auto-expand when debugging\n    if (window.__UI_DEBUG || window.__PHASE21_SHOW_TASK_EVENTS) {\n      body.style.display = \"block\";\n      btn.textContent = \"collapse\";\n    }\n  }\n\n  function appendLine(text) {\n    const body = document.getElementById(\"task-events-log-body\");\n    if (!body) return;\n    const div = document.createElement(\"div\");\n    div.style.whiteSpace = \"pre-wrap\";\n    div.style.wordBreak = \"break-word\";\n    div.textContent = text;\n    body.appendChild(div);\n    while (body.childNodes.length > 140) body.removeChild(body.firstChild);\n    body.scrollTop = body.scrollHeight;\n  }\n\n  function setHeaderStatus(text) {\n    const t = document.getElementById(\"task-events-log-title\");\n    if (t) t.textContent = text;\n  }\n\n  function start() {\n    ensureMiniPanel();\n    ensureSnapshot();\n\n    const es = new EventSource(URL);\n    window.__taskEventsES = es;\n\n    es.onopen = () => {\n      const snap = ensureSnapshot();\n      snap.connected = true;\n      snap.readyState = es.readyState;\n\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"sse.open\", event: \"open\", url: URL };\n      pushItem(item);\n      setHeaderStatus(\"TASK EVENTS \u00B7 connected\");\n      appendLine(`[${item.iso}] open ${URL}`);\n    };\n\n    es.onerror = () => {\n      const snap = ensureSnapshot();\n      snap.connected = false;\n      snap.readyState = es.readyState;\n\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"sse.error\", event: \"error\", url: URL, readyState: es.readyState };\n      pushItem(item);\n      setHeaderStatus(`TASK EVENTS \u00B7 error (readyState=${es.readyState})`);\n      appendLine(`[${item.iso}] error readyState=${es.readyState}`);\n    };\n\n    // default \"message\"\n    es.onmessage = (ev) => {\n      const payload = safeJson(ev.data);\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"message\", event: \"message\", data: payload ?? ev.data };\n      pushItem(item);\n      appendLine(`[${item.iso}] message :: ${payload ? JSON.stringify(payload) : String(ev.data)}`);\n    };\n\n    // named events (include what server ACTUALLY emits: task.event)\n    const names = [\n      \"hello\",\n      \"heartbeat\",\n      \"task.event\",\n      \"task.lifecycle\",\n      \"task.created\",\n      \"task.updated\",\n      \"task.completed\",\n      \"task.failed\",\n      \"error\",\n    ];\n\n    for (const name of names) {\n      try {\n        es.addEventListener(name, (ev) => {\n          const payload = safeJson(ev.data);\n          const item = { ts: Date.now(), iso: nowIso(), kind: \"event\", event: name, data: payload ?? ev.data };\n          pushItem(item);\n          appendLine(`[${item.iso}] ${name} :: ${payload ? JSON.stringify(payload) : String(ev.data)}`);\n        });\n      } catch {}\n    }\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", start, { once: true });\n  } else {\n    start();\n  }\n})();\n", "/**\n * Phase 16: Dashboard wiring for OPS + Reflections SSE streams.\n *\n * - Consume /events/ops + /events/reflections via EventSource\n * - Treat *.state as \"initial paint\" (replace baseline state)\n * - Treat subsequent events as incremental updates (merge / patch)\n * - Add tiny \u201Cconnected / last event\u201D UI indicator for each stream\n *\n * NOTE: Your SSE server emits NAMED events (e.g. \"ops.state\", \"reflections.state\").\n * EventSource.onmessage only receives UNNAMED events, so we must addEventListener()\n * for the named event types we care about.\n */\n\n(() => {\n  \"use strict\";\n\n  const OPS_SSE_URL = \"/events/ops\";\n  const REFLECTIONS_SSE_URL = \"/events/reflections\";\n\n  const NOW = () => Date.now();\n\n  function safeJsonParse(s) {\n    try { return JSON.parse(s); } catch { return null; }\n  }\n\n  function formatAge(ms) {\n    if (!Number.isFinite(ms)) return \"\u2014\";\n    const s = Math.floor(ms / 1000);\n    if (s < 60) return `${s}s`;\n    const m = Math.floor(s / 60);\n    if (m < 60) return `${m}m`;\n    return `${Math.floor(m / 60)}h`;\n  }\n\n  function el(tag, attrs = {}, text = \"\") {\n    const n = document.createElement(tag);\n    for (const [k, v] of Object.entries(attrs)) {\n      if (k === \"class\") n.className = v;\n      else if (k === \"style\") n.setAttribute(\"style\", v);\n      else n.setAttribute(k, v);\n    }\n    if (text) n.textContent = text;\n    return n;\n  }\n\n  function ensureStyles() {\n    if (document.getElementById(\"phase16-sse-style\")) return;\n    const s = el(\"style\", { id: \"phase16-sse-style\" });\n    s.textContent = `\n      .sse-indicator {\n        display:inline-flex;\n        align-items:center;\n        gap:6px;\n        font-size:11px;\n        line-height:1;\n        opacity:.85;\n        user-select:none;\n        white-space:nowrap;\n      }\n      .sse-indicator .dot {\n        width:7px; height:7px; border-radius:999px;\n        background:#555;\n        box-shadow:0 0 0 1px rgba(255,255,255,.08) inset;\n      }\n      .sse-indicator[data-connected=\"true\"] .dot { background:#2dd4bf; }\n      .sse-indicator[data-connected=\"false\"] .dot { background:#f97316; }\n      .sse-indicator .meta { font-variant-numeric: tabular-nums; }\n    `;\n    document.head.appendChild(s);\n  }\n\n  function mount(anchor, id, label) {\n    ensureStyles();\n\n    if (!anchor) {\n      let tray = document.getElementById(\"phase16-sse-tray\");\n      if (!tray) {\n        tray = el(\"div\", {\n          id: \"phase16-sse-tray\",\n          style: [\n            \"position:fixed\",\n            \"left:10px\",\n            \"bottom:10px\",\n            \"display:flex\",\n            \"flex-direction:column\",\n            \"gap:6px\",\n            \"z-index:9999\",\n            \"pointer-events:none\",\n          ].join(\";\")\n        });\n        document.body.appendChild(tray);\n      }\n      anchor = tray;\n    }\n\n    let node = document.getElementById(id);\n    if (node) return node;\n\n    node = el(\"span\", { id, class: \"sse-indicator\", \"data-connected\": \"false\" });\n    node.append(\n      el(\"span\", { class: \"dot\", \"aria-hidden\": \"true\" }),\n      el(\"span\", { class: \"meta\" }, `${label}: disconnected \u00B7 last: \u2014`)\n    );\n\n    // try to place nicely; otherwise append\n    try {\n      if (anchor.matches && anchor.matches(\"header,h1,h2,h3,h4,strong\")) {\n        const wrap = el(\"span\", { style: \"margin-left:8px\" });\n        wrap.appendChild(node);\n        anchor.appendChild(wrap);\n      } else {\n        const wrap = el(\"div\", { style: \"margin-top:4px\" });\n        wrap.appendChild(node);\n        anchor.appendChild(wrap);\n      }\n    } catch {\n      anchor.appendChild(node);\n    }\n\n    return node;\n  }\n\n  function set(ind, label, connected, lastAt) {\n    if (!ind) return;\n    ind.dataset.connected = connected ? \"true\" : \"false\";\n    const meta = ind.querySelector(\".meta\");\n    if (!meta) return;\n    meta.textContent = `${label}: ${connected ? \"connected\" : \"disconnected\"} \u00B7 last: ${lastAt ? formatAge(NOW() - lastAt) : \"\u2014\"}`;\n  }\n\n  function ensureGlobal() {\n    window.__MB_STREAMS ||= {\n      ops: { connected: false, lastAt: 0, state: {}, es: null },\n      reflections: { connected: false, lastAt: 0, state: {}, es: null },\n    };\n    return window.__MB_STREAMS;\n  }\n\n  function shallowMerge(target, patch) {\n    if (!target || typeof target !== \"object\") target = {};\n    if (!patch || typeof patch !== \"object\") return target;\n    return Object.assign(target, patch);\n  }\n\n  // Minimal dot-path patch support: { path:\"a.b.c\", value:any }\n  function applyDotPathPatch(state, patch) {\n    if (!state || typeof state !== \"object\") state = {};\n    const path = patch && typeof patch.path === \"string\" ? patch.path : \"\";\n    if (!path) return state;\n    const parts = path.split(\".\").filter(Boolean);\n    if (!parts.length) return state;\n    let cur = state;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const k = parts[i];\n      if (!cur[k] || typeof cur[k] !== \"object\") cur[k] = {};\n      cur = cur[k];\n    }\n    cur[parts[parts.length - 1]] = patch.value;\n    return state;\n  }\n\n  function isStateEvent(evtType, parsed) {\n    if (typeof evtType === \"string\" && evtType.endsWith(\".state\")) return true;\n    if (parsed && typeof parsed === \"object\") {\n      if (parsed.state && typeof parsed.state === \"object\") return true;\n      if (typeof parsed.type === \"string\" && parsed.type.includes(\"state\")) return true;\n      if (typeof parsed.event === \"string\" && parsed.event.includes(\"state\")) return true;\n    }\n    return false;\n  }\n\n  function extractPayload(parsed) {\n    if (!parsed || typeof parsed !== \"object\") return parsed;\n    if (parsed.payload !== undefined) return parsed.payload;\n    if (parsed.data !== undefined) return parsed.data;\n    if (parsed.delta !== undefined) return parsed.delta;\n    if (parsed.patch !== undefined) return parsed.patch;\n    if (parsed.state !== undefined) return parsed.state;\n    return parsed;\n  }\n\n  function connect(key, label, url, ind) {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) {\n    return null;\n  }\n\n    const g = ensureGlobal();\n\n    // close any existing connection\n    try { g[key].es && g[key].es.close(); } catch {}\n    g[key].es = null;\n\n    const es = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(url));\n    g[key].es = es;\n\n\n    // Phase16: guard null EventSource before handlers\n    if (!es) return null;\n\n    const tick = () => set(ind, label, g[key].connected, g[key].lastAt);\n\n    es.onopen = () => { g[key].connected = true; tick(); };\n    es.onerror = () => { g[key].connected = false; tick(); };\n\n    const handle = (evtType, e) => {\n      g[key].lastAt = NOW();\n\n      const parsed = safeJsonParse(e && e.data ? e.data : \"\");\n      const payload = extractPayload(parsed);\n\n      if (isStateEvent(evtType, parsed)) {\n        // initial paint: replace\n        g[key].state = (payload && typeof payload === \"object\") ? payload : { value: payload };\n      } else {\n        // incremental: patch or merge\n        if (payload && typeof payload === \"object\") {\n          if (typeof payload.path === \"string\" && \"value\" in payload) {\n            g[key].state = applyDotPathPatch(g[key].state, payload);\n          } else {\n            g[key].state = shallowMerge(g[key].state, payload);\n          }\n        } else if (payload !== null && payload !== undefined) {\n          g[key].state = shallowMerge(g[key].state, { lastValue: payload });\n        }\n      }\n\n      tick();\n      try {\n        window.dispatchEvent(new CustomEvent(`mb:${key}:update`, {\n          detail: { event: evtType, state: g[key].state, raw: parsed }\n        }));\n      } catch {}\n    };\n\n    // Unnamed events (rare in your streams, but safe)\n    es.onmessage = (e) => handle(\"message\", e);\n\n    // Named events (your streams DO emit these)\n    const eventNames = [\n      \"hello\",\n      `${key}.state`,\n      `${key}.update`,\n      `${key}.patch`,\n      `${key}.delta`,\n      \"state\",\n      \"update\",\n      \"patch\",\n      \"delta\",\n    ];\n\n    for (const name of eventNames) {\n      try {\n        es.addEventListener(name, (e) => handle(name, e));\n      } catch {}\n    }\n\n    tick();\n  }\n\n  function findOpsAnchor() {\n    return (\n      document.getElementById(\"ops-pill\") ||\n      document.querySelector(\"[data-widget='ops-pill']\") ||\n      document.querySelector(\".ops-pill\") ||\n      document.querySelector(\"#ops\") ||\n      null\n    );\n  }\n\n  function findReflectionsAnchor() {\n    return (\n      document.getElementById(\"reflections-header\") ||\n      document.getElementById(\"reflections\") ||\n      document.querySelector(\"[data-panel='reflections']\") ||\n      document.querySelector(\".reflections\") ||\n      (() => {\n        const heads = Array.from(document.querySelectorAll(\"h1,h2,h3,h4,header,strong\"));\n        return heads.find(h => (h.textContent || \"\").toLowerCase().includes(\"reflections\")) || null;\n      })()\n    );\n  }\n\n  function boot() {\n    const opsInd = mount(findOpsAnchor(), \"ops-sse-indicator\", \"OPS SSE\");\n    const refInd = mount(findReflectionsAnchor(), \"reflections-sse-indicator\", \"Reflections SSE\");\n\n    connect(\"ops\", \"OPS SSE\", OPS_SSE_URL, opsInd);\n    connect(\"reflections\", \"Reflections SSE\", REFLECTIONS_SSE_URL, refInd);\n\n    // keep age ticking\n    setInterval(() => {\n      const g = ensureGlobal();\n      set(opsInd, \"OPS SSE\", g.ops.connected, g.ops.lastAt);\n      set(refInd, \"Reflections SSE\", g.reflections.connected, g.reflections.lastAt);\n    }, 1000);\n  }\n\n  document.readyState === \"loading\"\n    ? document.addEventListener(\"DOMContentLoaded\", boot, { once: true })\n    : boot();\n})();\n\n// PHASE16_CONNECT_GUARD_FIXED_1767139733\n", "// <0001fb02> Agent Status Row \u2013 live heartbeats from OPS SSE\n// - Renders status pills for Matilda, Cade, Effie, Atlas\n// - Listens to OPS SSE on port 3201\n// - Updates colors/text based on incoming status\n\n(() => {\n  const container = document.getElementById(\"agent-status-container\");\n  if (!container) {\n    console.warn(\"agent-status-row.js: #agent-status-container not found.\");\n    return;\n  }\n\n  // Clear placeholder text (e.g., \"Loading agents...\")\n  container.innerHTML = \"\";\n\n  const AGENTS = [\"Matilda\", \"Cade\", \"Effie\", \"Atlas\"];\n  const indicators = {};\n\n  const row = document.createElement(\"div\");\n  row.className = \"flex flex-wrap gap-4 items-center\";\n  container.appendChild(row);\n\n  AGENTS.forEach((name) => {\n    const pill = document.createElement(\"div\");\n    pill.className =\n      \"px-3 py-1 rounded-full bg-gray-700 text-sm flex items-center gap-2 shadow\";\n\n    const dot = document.createElement(\"span\");\n    dot.className = \"w-2 h-2 rounded-full bg-yellow-400\";\n\n    const label = document.createElement(\"span\");\n    label.textContent = `${name}: \u23F3`;\n\n    pill.dataset.agent = name.toLowerCase();\n    pill.append(dot, label);\n    row.appendChild(pill);\n\n    indicators[name.toLowerCase()] = { pill, dot, label };\n  });\n\n  const OPS_SSE_URL = `/events/ops`;\n  \n\n  const __DISABLE_OPTIONAL_SSE = (typeof window !== \"undefined\" && window.__DISABLE_OPTIONAL_SSE) === true;\n  if (__DISABLE_OPTIONAL_SSE) {\n    console.warn(\"[agent-status-row] Optional SSE disabled (Phase 16 pending):\", OPS_SSE_URL);\n    Object.keys(indicators).forEach((key) => applyVisual(key, \"unknown\"));\n    return;\n  }\nlet source;\n\n  try {\n    source = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(OPS_SSE_URL));\n  } catch (err) {\n    console.error(\"agent-status-row.js: Failed to open OPS SSE connection:\", err);\n    return;\n  }\n\n  function classifyStatus(statusString) {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) {\n    return null;\n  }\n\n    const s = (statusString || \"\").toLowerCase();\n    if (!s) return \"unknown\";\n    if (s.includes(\"error\") || s.includes(\"failed\") || s.includes(\"offline\")) {\n      return \"error\";\n    }\n    if (s.includes(\"online\") || s.includes(\"ready\") || s.includes(\"ok\")) {\n      return \"online\";\n    }\n    if (s.includes(\"queued\") || s.includes(\"pending\") || s.includes(\"init\")) {\n      return \"pending\";\n    }\n    return \"unknown\";\n  }\n\n  function applyVisual(agentKey, statusString) {\n    const indicator = indicators[agentKey];\n    if (!indicator) return;\n\n    const kind = classifyStatus(statusString);\n    const { pill, dot, label } = indicator;\n\n    // Reset base classes\n    dot.className = \"w-2 h-2 rounded-full\";\n    pill.classList.remove(\"border\", \"border-red-400\", \"border-green-400\", \"border-yellow-300\");\n\n    switch (kind) {\n      case \"online\":\n        dot.classList.add(\"bg-green-400\");\n        pill.classList.add(\"border\", \"border-green-400\");\n        break;\n      case \"error\":\n        dot.classList.add(\"bg-red-400\");\n        pill.classList.add(\"border\", \"border-red-400\");\n        break;\n      case \"pending\":\n        dot.classList.add(\"bg-yellow-300\");\n        pill.classList.add(\"border\", \"border-yellow-300\");\n        break;\n      case \"unknown\":\n      default:\n        dot.classList.add(\"bg-gray-500\");\n        break;\n    }\n\n    const prettyName = agentKey.charAt(0).toUpperCase() + agentKey.slice(1);\n    const finalStatus = statusString || \"unknown\";\n    label.textContent = `${prettyName}: ${finalStatus}`;\n  }\n\n  // Phase16: guard null EventSource before handlers\n  if (!source) return null;\n  source.onmessage = (event) => {\n    let payloadRaw = event.data;\n    let data;\n\n    try {\n      data = JSON.parse(payloadRaw);\n    } catch {\n      // If it's not JSON, ignore for agent-status purposes\n      return;\n    }\n\n    const agentName =\n      (data.agent || data.actor || data.source || data.worker || \"\").toString();\n    if (!agentName) return;\n\n    const key = agentName.toLowerCase();\n    if (!indicators[key]) {\n      // Ignore agents we don't show in the row\n      return;\n    }\n\n    const status = (data.status || data.state || data.level || \"\").toString() || \"unknown\";\n    applyVisual(key, status);\n  };\n\n  source.onerror = (err) => {\n    console.warn(\"agent-status-row.js: OPS SSE error:\", err);\n    // On error, show all as unknown (neutral gray)\n    Object.keys(indicators).forEach((key) => applyVisual(key, \"unknown\"));\n  };\n})();\n", "// <0001fad7> Phase 5.1 \u2014 Matilda \u2192 Cade \u2192 Effie Broadcast Visualization\n// Wrapped in a guarded init() so we don't create duplicate intervals on reload.\n\nconst BROADCAST_GUARD_KEY = \"__broadcastVisualizationInited\";\n\nconst nodes = [\"Matilda\", \"Cade\", \"Effie\"];\n\nfunction renderBroadcastNodes() {\nconst container = document.getElementById(\"broadcast-visual\");\nif (!container) return;\n\nconst parts = [];\nfor (let i = 0; i < nodes.length; i++) {\nconst n = nodes[i];\nparts.push('<div class=\"node\" id=\"node-' + n + '\">' + n + \"</div>\");\nif (i < nodes.length - 1) {\nparts.push('<div class=\"arrow\">\u279C</div>');\n}\n}\ncontainer.innerHTML = parts.join(\"\");\n}\n\nfunction startBroadcastCycle() {\nlet idx = 0;\n\nsetInterval(() => {\nconst allNodes = document.querySelectorAll(\".node\");\nallNodes.forEach((n) => n.classList.remove(\"active\"));\n\nconst activeId = \"node-\" + nodes[idx];\nconst active = document.getElementById(activeId);\nif (active) active.classList.add(\"active\");\n\nidx = (idx + 1) % nodes.length;\n\n}, 1500);\n}\n\n/**\n\n* Initialize the broadcast visualization in a guarded way so it\n* does not re-register intervals or duplicate DOM nodes.\n  */\n  export function initBroadcastVisualization() {\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n  return;\n  }\n\nif (window[BROADCAST_GUARD_KEY]) {\nreturn;\n}\nwindow[BROADCAST_GUARD_KEY] = true;\n\nconst run = () => {\nrenderBroadcastNodes();\nstartBroadcastCycle();\n};\n\nif (document.readyState === \"loading\") {\nwindow.addEventListener(\"DOMContentLoaded\", run);\n} else {\nrun();\n}\n}\n\n// Optional: expose for manual debugging in the browser console\nif (typeof window !== \"undefined\") {\nwindow.initBroadcastVisualization = initBroadcastVisualization;\n}\n", "// public/js/ops-status-widget.js\n// Phase 11: minimal pill ID normalizer; all state comes from ops-pill-state.js\n(function () {\n  if (typeof document === \"undefined\") return;\n\n  var existing = document.getElementById(\"ops-dashboard-pill\");\n  if (existing) return;\n\n  var pill = document.querySelector(\"[data-ops-pill]\");\n  if (!pill) return;\n\n  pill.id = \"ops-dashboard-pill\";\n})();\n", "// Lightweight OPS SSE \u2192 global state bridge for Phase 11\n(() => {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) return;\n\n  if (typeof window === \"undefined\" || typeof EventSource === \"undefined\") return;\n\n  // Avoid multiple initializations if bundle is loaded twice\n  if (window.__opsGlobalsBridgeInitialized) return;\n  window.__opsGlobalsBridgeInitialized = true;\n\n  // Initialize globals if they don't exist\n  if (typeof window.lastOpsHeartbeat === \"undefined\") {\n    window.lastOpsHeartbeat = null;\n  }\n  if (typeof window.lastOpsStatusSnapshot === \"undefined\") {\n    window.lastOpsStatusSnapshot = null;\n  }\n\n  const opsUrl = `/events/ops`;\n\n  \n\n  const __DISABLE_OPTIONAL_SSE = (typeof window !== \"undefined\" && window.__DISABLE_OPTIONAL_SSE) === true;\n  if (__DISABLE_OPTIONAL_SSE) {\n    console.warn(\"[ops-globals-bridge] Optional SSE disabled (Phase 16 pending):\", opsUrl);\n    return;\n  }\nconst handleEvent = (event) => {\n    try {\n      const data = JSON.parse(event.data || \"null\");\n      if (!data) return;\n\n      window.lastOpsHeartbeat = Math.floor(Date.now() / 1000);\n      window.lastOpsStatusSnapshot = data;\n    } catch (err) {\n      console.warn(\"[ops-globals-bridge] Failed to parse OPS event:\", err);\n    }\n  \n  // Phase16: emit a unified CustomEvent for OPS pill + listeners\n  try {\n    window.dispatchEvent(new CustomEvent(\"mb:ops:update\", {\n      detail: { event: \"message\", state: window.lastOpsStatusSnapshot }\n    }));\n  } catch {}\n};\n\n  try {\n    const es = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(opsUrl));\n\n    // Default unnamed \"message\" events (if any in future)\n    // Phase16: guard null EventSource before handlers\n\n    if (!es) return null;\n\n    es.onmessage = handleEvent;\n\n    // Named \"hello\" events from OPS SSE\n    es.addEventListener(\"hello\", handleEvent);\n\n    // Phase16: guard null EventSource before handlers (onerror)\n\n    if (!es) return;\n\n    es.onerror = (err) => {\n      console.warn(\"[ops-globals-bridge] EventSource error:\", err);\n    };\n  } catch (err) {\n    console.warn(\"[ops-globals-bridge] Failed to init EventSource:\", err);\n  }\n})();\n", "// public/js/ops-pill-state.js\n// Phase 11: simple dashboard OPS pill driven by lastOpsHeartbeat.\n// - Creates #ops-dashboard-pill on /dashboard if missing.\n// - Hides any external #ops-status-pill overlay.\n// - Shows \"OPS: Unknown\" / \"OPS: Online\" based on heartbeat.\n\n(function () {\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") return;\n  if (window.location.pathname !== \"/dashboard\") return;\n\n  var POLL_INTERVAL_MS = 5000;\n  var PILL_ID = \"ops-dashboard-pill\";\n\n  function ensurePill() {\n    var pill = document.getElementById(PILL_ID);\n    if (pill) return pill;\n\n    // Create the dashboard pill near the top of the body\n    pill = document.createElement(\"span\");\n    pill.id = PILL_ID;\n    pill.className = \"ops-pill ops-pill-unknown\";\n    pill.textContent = \"OPS: Unknown\";\n\n    // Keep styling minimal; main styles come from CSS class\n    pill.style.display = \"inline-block\";\n\n    if (document.body.firstChild) {\n      document.body.insertBefore(pill, document.body.firstChild);\n    } else {\n      document.body.appendChild(pill);\n    }\n\n    return pill;\n  }\n\n  function applyState() {\n    // Always hide any external overlay pill if present\n    var overlay = document.getElementById(\"ops-status-pill\");\n    if (overlay) {\n      overlay.style.display = \"none\";\n    }\n\n    var pill = ensurePill();\n    if (!pill) return;\n\n    var hasHeartbeat = (typeof window.lastOpsHeartbeat === \"number\");\n\n    var label = hasHeartbeat ? \"OPS: Online\"  : \"OPS: Unknown\";\n    var cls   = hasHeartbeat ? \"ops-pill-online\" : \"ops-pill-unknown\";\n\n    pill.classList.remove(\n      \"ops-pill-unknown\",\n      \"ops-pill-online\",\n      \"ops-pill-stale\",\n      \"ops-pill-error\"\n    );\n    pill.classList.add(cls);\n    pill.textContent = label;\n  }\n\n  applyState();\n  setInterval(applyState, POLL_INTERVAL_MS);\n})();\n", "/**\n * Tasks Widget (stable, no SSE)\n * - GET /api/tasks\n * - POST /api/complete-task\n * - No optimistic removal (prevents list blinking)\n */\n(() => {\n  const API = {\n    list: \"/api/tasks\",\n    complete: \"/api/complete-task\",\n  };\n\n  const SELECTORS = [\n    \"#tasks-widget\",\n    \"#tasksWidget\",\n    \"[data-tasks-widget]\",\n    \"[data-widget='tasks']\",\n  ];\n\n  const state = {\n    tasks: [],\n    loading: false,\n    lastError: null,\n    inflightComplete: new Set(),\n  };\n\n  function $(sel, root = document) {\n    return root.querySelector(sel);\n  }\n\n  function findMount() {\n    for (const sel of SELECTORS) {\n      const el = $(sel);\n      if (el) return el;\n    }\n    return null;\n  }\n\n  function esc(s) {\n    return String(s ?? \"\")\n      .replaceAll(\"&\", \"&amp;\")\n      .replaceAll(\"<\", \"&lt;\")\n      .replaceAll(\">\", \"&gt;\")\n      .replaceAll('\"', \"&quot;\")\n      .replaceAll(\"'\", \"&#39;\");\n  }\n\n  async function apiJson(url, opts = {}) {\n    const res = await fetch(url, {\n      method: opts.method || \"GET\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: opts.body ? JSON.stringify(opts.body) : undefined,\n    });\n    const json = await res.json();\n    if (!res.ok) throw new Error(json?.error || \"Request failed\");\n    return json;\n  }\n\n  async function fetchTasks() {\n    state.loading = true;\n    render();\n    try {\n      const data = await apiJson(API.list);\n      state.tasks = (data.tasks || []).map(t => ({\n        id: String(t.id),\n        title: t.title || \"\",\n        status: t.status || \"\",\n      }));\n    } catch (e) {\n      state.lastError = e.message;\n    } finally {\n      state.loading = false;\n      render();\n    }\n  }\n\n  async function completeTask(taskId) {\n    if (state.inflightComplete.has(taskId)) return;\n    state.inflightComplete.add(taskId);\n    render();\n\n    try {\n      await apiJson(API.complete, {\n        method: \"POST\",\n        body: { taskId },\n      });\n    } catch (e) {\n      state.lastError = e.message;\n    } finally {\n      state.inflightComplete.delete(taskId);\n      await fetchTasks();\n    }\n  }\n\n  function render() {\n    const mount = findMount();\n    if (!mount) return;\n\n    mount.innerHTML = `\n      <div>\n        \n        ${state.lastError ? `<div style=\"color:red\">${esc(state.lastError)}</div>` : \"\"}\n        <div>\n          ${state.tasks.map(t => `\n            <div style=\"display:flex;justify-content:space-between;gap:8px\">\n              <span>${esc(t.title)}</span>\n              ${\n                ([\"complete\",\"completed\",\"done\"].includes(String(t.status||\"\").toLowerCase()))\n                  ? `<span style=\"opacity:.5;font-size:12px\">Completed</span>`\n                  : `<button data-id=\"${t.id}\">Complete</button>`\n              }\n            </div>\n          `).join(\"\")}\n        </div>\n      </div>\n    `;\n\n    mount.querySelectorAll(\"button[data-id]\").forEach(btn => {\n      btn.onclick = () => completeTask(btn.dataset.id);\n    });\n  }\n\n  document.addEventListener(\"DOMContentLoaded\", fetchTasks);\n\n  // Phase22: SSE-driven refresh (ignore heartbeats)\n  window.addEventListener(\"mb.task.event\", (e) => {\n    const k = String(e?.detail?.kind || e?.detail?.type || \"\");\n    if (k === \"heartbeat\") return;\n    fetchTasks();\n  });\n\n// Phase22: SSE-driven refresh\n  window.addEventListener(\"mb.task.event\", () => { fetchTasks(); });\n\n// Auto-refresh (no SSE): keep widget feeling live\n  setInterval(() => { fetchTasks(); }, 5000);\n\n})();\n", "(function () {\n  function log(msg) {\n    console.log(\"[matilda-chat]\", msg);\n  }\n\n  function appendMessage(transcriptEl, sender, text) {\n    if (!transcriptEl) return;\n    var line = document.createElement(\"p\");\n    line.className = \"mb-1 text-sm\";\n    var label = sender ? sender + \": \" : \"\";\n    line.textContent = label + text;\n    transcriptEl.appendChild(line);\n    transcriptEl.scrollTop = transcriptEl.scrollHeight;\n  }\n\n  function setSendingState(sendBtn, input, isSending) {\n    if (sendBtn) {\n      sendBtn.disabled = isSending;\n      sendBtn.classList.toggle(\"opacity-60\", isSending);\n      sendBtn.textContent = isSending ? \"Sending...\" : \"Send\";\n    }\n    if (input) {\n      input.disabled = isSending;\n    }\n  }\n\n  async function wireChat() {\n    var root = document.getElementById(\"matilda-chat-root\");\n    if (!root) {\n      log(\"No #matilda-chat-root found; skipping wiring.\");\n      return;\n    }\n\n    var transcript = document.getElementById(\"matilda-chat-transcript\");\n    var input = document.getElementById(\"matilda-chat-input\");\n    var sendBtn = document.getElementById(\"matilda-chat-send\");\n\n    if (!transcript || !input || !sendBtn) {\n      log(\"Missing one or more Matilda chat elements; aborting wiring.\");\n      return;\n    }\n\n    function safeTrim(value) {\n      return (value || \"\").toString().trim();\n    }\n\n    async function handleSend() {\n      var message = safeTrim(input.value);\n      if (!message) return;\n\n      appendMessage(transcript, \"You\", message);\n      input.value = \"\";\n      setSendingState(sendBtn, input, true);\n\n      try {\n        var res = await fetch(\"/api/chat\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ message: message, agent: \"matilda\" }),\n        });\n\n        if (!res.ok) {\n          appendMessage(\n            transcript,\n            \"Matilda\",\n            \"(error talking to /api/chat)\"\n          );\n          return;\n        }\n\n        var data = await res.json();\n        var reply =\n          (data && (data.reply || data.message || data.response)) ||\n          \"(no reply)\";\n        appendMessage(transcript, \"Matilda\", reply);\n      } catch (err) {\n        console.error(err);\n        appendMessage(transcript, \"Matilda\", \"(network error)\");\n      } finally {\n        setSendingState(sendBtn, input, false);\n      }\n    }\n\n    sendBtn.addEventListener(\"click\", handleSend);\n\n    var quickBtn = document.getElementById(\"matilda-chat-quick-check\");\n    if (quickBtn) {\n      quickBtn.addEventListener(\"click\", function () {\n        input.value = \"Quick systems check from dashboard Phase 11.4.\";\n        handleSend();\n      });\n    }\n\n    input.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Enter\" && !e.shiftKey) {\n        e.preventDefault();\n        handleSend();\n      }\n    });\n\n    log(\"Matilda chat wiring complete.\");\n  }\n\n  document.addEventListener(\"DOMContentLoaded\", wireChat);\n})();\n", "(() => {\n  const SSE_URL = \"/events/task-events\";\n\n  const PANEL_ID = \"mb-task-events-panel\";\n  const FEED_ID = \"mb-task-events-feed\";\n  const COUNTS_ID = \"mb-task-events-counts\";\n  const ANCHOR_ID = \"mb-task-events-panel-anchor\";\n\n  function mountRoot() {\n    const anchor = document.getElementById(ANCHOR_ID);\n    if (anchor) return anchor;\n    return document.body;\n  }\n\n  function ensurePanel() {\n    if (document.getElementById(PANEL_ID)) return;\n\n    const root = mountRoot();\n\n    const panel = document.createElement(\"div\");\n    panel.id = PANEL_ID;\n\n    // If anchored, behave like an in-page card; otherwise float.\n    const anchored = root && root.id === ANCHOR_ID;\n\n    panel.style.width = anchored ? \"100%\" : \"360px\";\n    panel.style.maxWidth = anchored ? \"100%\" : \"calc(100vw - 24px)\";\n    panel.style.maxHeight = anchored ? \"260px\" : \"40vh\";\n    panel.style.overflow = \"hidden\";\n    panel.style.zIndex = \"9999\";\n    panel.style.border = \"1px solid rgba(255,255,255,0.12)\";\n    panel.style.borderRadius = \"14px\";\n    panel.style.background = \"rgba(10,10,14,0.92)\";\n    panel.style.backdropFilter = \"blur(10px)\";\n    panel.style.boxShadow = \"0 10px 30px rgba(0,0,0,0.35)\";\n    panel.style.color = \"rgba(255,255,255,0.92)\";\n    panel.style.fontFamily =\n      \"ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace\";\n\n    if (!anchored) {\n      panel.style.position = \"fixed\";\n      panel.style.right = \"12px\";\n      panel.style.bottom = \"12px\";\n    } else {\n      panel.style.marginTop = \"12px\";\n    }\n\n    const header = document.createElement(\"div\");\n    header.style.display = \"flex\";\n    header.style.alignItems = \"center\";\n    header.style.justifyContent = \"space-between\";\n    header.style.gap = \"8px\";\n    header.style.padding = \"10px 12px\";\n    header.style.borderBottom = \"1px solid rgba(255,255,255,0.10)\";\n\n    const title = document.createElement(\"div\");\n    title.textContent = \"TASK EVENTS (live)\";\n    title.style.fontSize = \"12px\";\n    title.style.letterSpacing = \"0.08em\";\n    title.style.opacity = \"0.9\";\n\n    const right = document.createElement(\"div\");\n    right.style.display = \"flex\";\n    right.style.alignItems = \"center\";\n    right.style.gap = \"10px\";\n\n    const counts = document.createElement(\"div\");\n    counts.id = COUNTS_ID;\n    counts.textContent = \"created:0  completed:0  failed:0\";\n    counts.style.fontSize = \"11px\";\n    counts.style.opacity = \"0.85\";\n\n    const dot = document.createElement(\"span\");\n    dot.setAttribute(\"aria-label\", \"task-events connection\");\n    dot.title = \"task-events connection\";\n    dot.style.display = \"inline-block\";\n    dot.style.width = \"10px\";\n    dot.style.height = \"10px\";\n    dot.style.borderRadius = \"999px\";\n    dot.style.background = \"rgba(255,255,255,0.25)\";\n    dot.style.boxShadow = \"0 0 0 2px rgba(255,255,255,0.08) inset\";\n\n    const btn = document.createElement(\"button\");\n    btn.type = \"button\";\n    btn.textContent = \"\u00D7\";\n    btn.title = \"hide\";\n    btn.style.cursor = \"pointer\";\n    btn.style.border = \"1px solid rgba(255,255,255,0.14)\";\n    btn.style.background = \"transparent\";\n    btn.style.color = \"rgba(255,255,255,0.85)\";\n    btn.style.borderRadius = \"10px\";\n    btn.style.width = \"28px\";\n    btn.style.height = \"24px\";\n    btn.style.lineHeight = \"22px\";\n    btn.style.fontSize = \"14px\";\n    btn.onclick = () => panel.remove();\n\n    right.appendChild(dot);\n    right.appendChild(counts);\n    right.appendChild(btn);\n\n    header.appendChild(title);\n    header.appendChild(right);\n\n    const feed = document.createElement(\"div\");\n    feed.id = FEED_ID;\n    feed.style.padding = \"10px 12px\";\n    feed.style.overflow = \"auto\";\n    feed.style.maxHeight = anchored ? \"200px\" : \"calc(40vh - 46px)\";\n\n    panel.appendChild(header);\n    panel.appendChild(feed);\n\n    root.appendChild(panel);\n\n    window.__MB_TASK_EVENTS_PANEL = { dot, feed, counts };\n    console.log(\"[phase22] task-events panel mounted (anchored=%s)\", anchored);\n  }\n\n  function setDot(state) {\n    ensurePanel();\n    const dot = window.__MB_TASK_EVENTS_PANEL?.dot;\n    if (!dot) return;\n    if (state === \"open\") dot.style.background = \"rgba(80,200,120,0.85)\";\n    else if (state === \"error\") dot.style.background = \"rgba(240,90,90,0.85)\";\n    else dot.style.background = \"rgba(255,255,255,0.25)\";\n  }\n\n  const seen = new Set();\n  const tally = { created: 0, completed: 0, failed: 0 };\n\n  function bumpCounts(kind) {\n    if (kind === \"task.created\") tally.created += 1;\n    if (kind === \"task.completed\") tally.completed += 1;\n    if (kind === \"task.failed\") tally.failed += 1;\n\n    const el = document.getElementById(COUNTS_ID);\n    if (el) el.textContent = `created:${tally.created}  completed:${tally.completed}  failed:${tally.failed}`;\n  }\n\n  function formatLine(ev, fallbackKind) {\n    const ts = typeof ev.ts === \"number\" ? new Date(ev.ts).toISOString() : new Date().toISOString();\n    const tid = ev.task_id ?? ev.id ?? ev.taskId ?? \"unknown\";\n    const run = ev.run_id ?? ev.runId ?? \"\";\n    const msg = ev.msg ?? ev.message ?? \"\";\n    const extras = [];\n    if (run) extras.push(`run=${run}`);\n    if (ev.actor) extras.push(`actor=${ev.actor}`);\n    if (ev.status) extras.push(`status=${ev.status}`);\n    if (typeof ev.cursor === \"number\") extras.push(`cursor=${ev.cursor}`);\n    const extraStr = extras.length ? ` (${extras.join(\" \")})` : \"\";\n    return `${ts}  ${(ev.kind ?? fallbackKind ?? \"event\")}  task=${tid}${extraStr}${msg ? \" \u2014 \" + msg : \"\"}`;\n  }\n\n  function appendLine(text, kind) {\n    ensurePanel();\n    const feed = document.getElementById(FEED_ID);\n    if (!feed) return;\n\n    const row = document.createElement(\"div\");\n    row.style.whiteSpace = \"pre-wrap\";\n    row.style.wordBreak = \"break-word\";\n    row.style.fontSize = \"11px\";\n    row.style.lineHeight = \"1.35\";\n    row.style.padding = \"6px 8px\";\n    row.style.border = \"1px solid rgba(255,255,255,0.10)\";\n    row.style.borderRadius = \"12px\";\n    row.style.marginBottom = \"8px\";\n    row.style.background = \"rgba(255,255,255,0.03)\";\n\n    if (kind === \"task.completed\") row.style.borderColor = \"rgba(80,200,120,0.35)\";\n    if (kind === \"task.failed\") row.style.borderColor = \"rgba(240,90,90,0.35)\";\n    if (kind === \"heartbeat\") row.style.opacity = \"0.65\";\n\n    row.textContent = text;\n    feed.prepend(row);\n\n    const children = Array.from(feed.children);\n    if (children.length > 60) {\n      for (let i = 60; i < children.length; i++) children[i].remove();\n    }\n  }\n\n  function dispatchWindowEvent(ev) {\n    try { window.dispatchEvent(new CustomEvent(\"mb.task.event\", { detail: ev })); } catch {}\n  }\n\n  function parseMaybeJSON(raw) {\n    try { return JSON.parse(raw); } catch { return null; }\n  }\n\n  function handleFrame(eventName, rawData) {\n    const data = typeof rawData === \"string\" ? parseMaybeJSON(rawData) : rawData;\n    const ev = (data && typeof data === \"object\") ? data : { kind: eventName, raw: rawData };\n\n      // Phase22 normalization:\n      // server sends event: task.event with payload { type:\"task.created|task.completed|task.failed\", taskId:\"...\" }\n      if (eventName === \"task.event\") {\n        if (!ev.kind && ev.type) ev.kind = ev.type;\n        if (ev.kind === \"task.event\" && ev.type) ev.kind = ev.type;\n        if (ev.task_id == null && ev.taskId != null) ev.task_id = ev.taskId;\n        if (ev.run_id == null && ev.runId != null) ev.run_id = ev.runId;\n      }\n\n    if (!ev.kind) ev.kind = eventName;\n\n    const key = `${eventName}|${ev.kind}|${ev.ts ?? \"\"}|${ev.task_id ?? ev.id ?? \"\"}|${ev.run_id ?? \"\"}|${ev.cursor ?? \"\"}`;\n    if (seen.has(key)) return;\n    seen.add(key);\n\n    if (ev.kind === \"task.created\" || ev.kind === \"task.completed\" || ev.kind === \"task.failed\") {\n      bumpCounts(String(ev.kind));\n    }\n\n    appendLine(formatLine(ev, eventName), String(ev.kind ?? eventName));\n    dispatchWindowEvent(ev);\n  }\n\n  let es = null;\n  let attempt = 0;\n\n  function connect() {\n    ensurePanel();\n\n    if (es) {\n      try { es.close(); } catch {}\n      es = null;\n    }\n\n    const url = SSE_URL;\n    es = new EventSource(url);\n\n    es.onopen = () => {\n      attempt = 0;\n      setDot(\"open\");\n      appendLine(`${new Date().toISOString()}  sse.open  url=${url}`, \"sse.open\");\n      console.log(\"[phase22] task-events SSE open\", url);\n    };\n\n    es.onerror = () => {\n      setDot(\"error\");\n      try { es.close(); } catch {}\n      es = null;\n\n      attempt += 1;\n      const delay = Math.min(15000, 500 * Math.pow(2, Math.min(6, attempt)));\n      appendLine(`${new Date().toISOString()}  sse.error  reconnect_in=${delay}ms`, \"sse.error\");\n      console.log(\"[phase22] task-events SSE error; reconnect in\", delay);\n      setTimeout(connect, delay);\n    };\n\n    es.onmessage = (msg) => handleFrame(\"message\", msg.data);\n\n    const names = [\n      \"hello\",\n      \"heartbeat\",\n      \"task.event\",\n      \"task.created\",\n      \"task.completed\",\n      \"task.failed\",\n      \"task.updated\",\n      \"task.status\",\n    ];\n    for (const name of names) {\n      es.addEventListener(name, (e) => handleFrame(name, e.data));\n    }\n  }\n\n  function boot() {\n    connect();\n    // Guard: if something removes the panel, re-mount + reconnect.\n    setInterval(() => {\n      if (!document.getElementById(PANEL_ID)) {\n        try { connect(); } catch {}\n      }\n    }, 2000);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", boot, { once: true });\n  } else {\n    boot();\n  }\n\n  window.__MB_TASK_EVENTS = { url: SSE_URL, reconnect: () => connect() };\n})();\n", "(() => {\n  // Phase 22: bind task-events SSE -> Task Delegation + status UI (best-effort)\n\n  const TASK_EVENT_NAME = \"mb.task.event\";\n  const tasks = new Map();\n\n  const STATUS_CLASS = {\n    queued: \"task-status-queued\",\n    done: \"task-status-done\",\n    failed: \"task-status-failed\",\n  };\n\n  function normStatus(s) {\n    const v = String(s ?? \"\").toLowerCase();\n    if (v === \"queued\" || v === \"pending\") return \"queued\";\n    if (v === \"done\" || v === \"complete\" || v === \"completed\") return \"done\";\n    if (v === \"failed\" || v === \"error\") return \"failed\";\n    return v || \"unknown\";\n  }\n\n  function pluckId(ev) {\n    return ev?.task_id ?? ev?.taskId ?? ev?.id ?? ev?.task?.id ?? null;\n  }\n\n  function pluckTask(ev) {\n    const t = ev?.task && typeof ev.task === \"object\" ? ev.task : null;\n    const id = pluckId(ev);\n    const status =\n      ev?.status ??\n      ev?.payload?.status ??\n      t?.status ??\n      (ev?.kind === \"task.created\" ? \"queued\" : null);\n\n    return {\n      id: id != null ? String(id) : null,\n      status: status != null ? normStatus(status) : null,\n      title: t?.title ?? ev?.title ?? null,\n      agent: t?.agent ?? ev?.agent ?? null,\n      error: ev?.error ?? ev?.payload?.error ?? t?.error ?? null,\n      updated_at: t?.updated_at ?? ev?.ts ?? Date.now(),\n    };\n  }\n\n  function setStatusOnNode(node, status) {\n    if (!node) return;\n    const s = normStatus(status);\n    node.setAttribute(\"data-task-status\", s);\n    node.classList?.remove(...Object.values(STATUS_CLASS));\n    if (STATUS_CLASS[s]) node.classList?.add(STATUS_CLASS[s]);\n\n    const sub =\n      node.querySelector?.(\"[data-task-field='status']\") ||\n      node.querySelector?.(\".task-status\") ||\n      node.querySelector?.(\".status\") ||\n      null;\n    if (sub) sub.textContent = s;\n  }\n\n  function updateTaskRowUI(task) {\n    if (!task?.id) return;\n    const id = String(task.id);\n    const nodes = [\n      document.getElementById(`task-${id}`),\n      document.getElementById(`task_${id}`),\n      document.querySelector?.(`[data-task-id=\"${CSS.escape(id)}\"]`),\n      document.querySelector?.(`[data-taskid=\"${CSS.escape(id)}\"]`),\n    ].filter(Boolean);\n\n    for (const n of nodes) setStatusOnNode(n, task.status);\n  }\n\n  function updateCountersUI() {\n    let queued = 0, done = 0, failed = 0;\n    for (const t of tasks.values()) {\n      const s = normStatus(t.status);\n      if (s === \"queued\") queued++;\n      else if (s === \"done\") done++;\n      else if (s === \"failed\") failed++;\n    }\n\n    const map = [\n      [\"queued\", queued],\n      [\"done\", done],\n      [\"failed\", failed],\n    ];\n\n    for (const [k, v] of map) {\n      const el =\n        document.getElementById(`task-count-${k}`) ||\n        document.getElementById(`tasks-${k}-count`) ||\n        document.querySelector?.(`[data-task-count=\"${k}\"]`) ||\n        null;\n      if (el) el.textContent = String(v);\n    }\n  }\n\n  function ingestTask(task) {\n    if (!task?.id) return;\n    const id = String(task.id);\n    const prev = tasks.get(id) || {};\n    const next = { ...prev, ...task, id, status: task.status ?? prev.status };\n    tasks.set(id, next);\n    updateTaskRowUI(next);\n    updateCountersUI();\n  }\n\n  function onTaskEvent(ev) {\n    const t = pluckTask(ev);\n    if (!t.id && ev?.kind) {\n      if (ev.kind === \"task.completed\") t.status = \"done\";\n      if (ev.kind === \"task.failed\") t.status = \"failed\";\n    }\n    if (t.id) ingestTask(t);\n  }\n\n  function attach() {\n    if (window.__PHASE22_TASK_UI_BOUND) return;\n    window.__PHASE22_TASK_UI_BOUND = true;\n\n    window.addEventListener(TASK_EVENT_NAME, (e) => {\n      try { if (window.__UI_DEBUG || window.__PHASE22_DEBUG) if (window.__UI_DEBUG || window.__PHASE22_DEBUG) console.log(\"[phase22] mb.task.event\", e.detail); onTaskEvent(e.detail); } catch {}\n    });\n\n    window.__PHASE22_TASK_UI = { tasks }; console.log(\"[phase22] bindings attached\");\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", attach, { once: true });\n  } else {\n    attach();\n  }\n})();\n", "import \"./sse-heartbeat-shim.js\";\nimport \"./heartbeat-stale-indicator.js\";\nimport \"./task-events-sse-listener.js\";\n// Phase 11 \u2013 Unified dashboard bundle entrypoint\n\n// Core dashboard status + tiles\nimport \"./dashboard-status.js\";\n\n// Phase 15/16 boundary: disable optional SSE (OPS + Reflections) until backends exist\nif (typeof window !== \"undefined\" && typeof window.__DISABLE_OPTIONAL_SSE === \"undefined\") {\n  window.__DISABLE_OPTIONAL_SSE = false;\n}\n\nimport \"./agent-status-row.js\";\n\n// OPS / PM2 status + SSE wiring\nimport \"./dashboard-broadcast.js\";\nimport \"./ops-status-widget.js\";\nimport \"./ops-globals-bridge.js\";\nimport \"./ops-pill-state.js\";\nimport \"./dashboard-tasks-widget.js\";\n\n// Matilda chat console wiring\nimport \"./matilda-chat-console.js\";\n\n// TEMP: dashboard graph disabled until canvas is present on all pages\n// import \"./dashboard-graph.js\";\n\n\n// Phase 22: task-events live UI\nimport \"./task-events-sse-client.js\";\nimport \"./phase22_task_delegation_live_bindings.js\";\n"],
- public/js/task-events-sse-client.js:141:  function formatLine(ev, fallbackKind) {
- public/js/task-events-sse-client.js:152:    return `${ts}  ${(ev.kind ?? fallbackKind ?? "event")}  task=${tid}${extraStr}${msg ? " â€” " + msg : ""}`;
- public/js/dashboard-delegation.js:112:"[dashboard-delegation] delegation response (fallback):",
- public/scripts/agent-status-row.js:11:  // fallback: first element that contains "Dashboard" and "Phase"
- public/js/dashboard-tasks-widget.js:5: * - No optimistic removal (prevents list blinking)
- 
- ## 4) SSE disconnect/error implying lifecycle
- public/js/reflections-sse-dashboard.js:10:// TODO: Re-enable EventSource wiring once a valid text/event-stream endpoint
- public/js/sse-reflections-shim.js:1:// Phase 11 â€“ SSE shim to disable Reflections EventSource until backend is ready
- public/bundle.js.map:4:  "sourcesContent": ["/**\n * Phase 16 \u2013 Shared Heartbeat Bus (OPS + Tasks)\n *\n * Wrap EventSource so connection + any SSE message updates a normalized heartbeat store.\n *\n * Exposes:\n *   window.__HB = { record(kind, ts), get(kind), snapshot() }\n *\n * kind: \"ops\" | \"tasks\" | \"reflections\" | \"unknown\"\n */\n(function () {\n  const w = window;\n\n  const STORE_KEY = \"__HB\";\n  if (!w[STORE_KEY]) {\n    const state = { ops: null, tasks: null, reflections: null, unknown: null };\n    w[STORE_KEY] = {\n      record(kind, ts) {\n        const k = Object.prototype.hasOwnProperty.call(state, kind) ? kind : \"unknown\";\n        state[k] = typeof ts === \"number\" ? ts : Date.now();\n        return state[k];\n      },\n      get(kind) {\n        const k = Object.prototype.hasOwnProperty.call(state, kind) ? kind : \"unknown\";\n        return state[k];\n      },\n      snapshot() {\n        return { ...state };\n      },\n    };\n  }\n\n  const NativeEventSource = w.EventSource;\n  if (!NativeEventSource || NativeEventSource.__hbWrapped) return;\n\n  function classify(url) {\n    const u = String(url || \"\");\n    if (u.includes(\"/events/ops\")) return \"ops\";\n    if (u.includes(\"/events/tasks\")) return \"tasks\";\n    if (u.includes(\"/events/reflections\")) return \"reflections\";\n    return \"unknown\";\n  }\n\n  function HeartbeatEventSource(url, eventSourceInitDict) {\n    const kind = classify(url);\n\n    // Record immediately on connection attempt so \"connected but quiet\" still looks alive.\n    try { w[STORE_KEY].record(kind, Date.now()); } catch (_) {}\n\n    const es = new NativeEventSource(url, eventSourceInitDict);\n\n    const update = () => {\n      try { w[STORE_KEY].record(kind, Date.now()); } catch (_) {}\n    };\n\n    // Update heartbeat when the connection opens (most reliable for \"alive\").\n    try { es.addEventListener(\"open\", update); } catch (_) {}\n\n    // Update heartbeat on any message for this stream.\n    try { es.addEventListener(\"message\", update); } catch (_) {}\n\n    // Also wrap onmessage if assigned later.\n    let _onmessage = null;\n    Object.defineProperty(es, \"onmessage\", {\n      get() { return _onmessage; },\n      set(fn) {\n        _onmessage = function (ev) {\n          update();\n          if (typeof fn === \"function\") return fn.call(es, ev);\n        };\n      },\n      configurable: true,\n    });\n\n    // Update heartbeat when errors occur too (helps show \"something happened\" vs silence).\n    try { es.addEventListener(\"error\", update); } catch (_) {}\n\n    return es;\n  }\n\n  HeartbeatEventSource.prototype = NativeEventSource.prototype;\n  HeartbeatEventSource.__hbWrapped = true;\n\n  w.EventSource = HeartbeatEventSource;\n})();\n", "/**\n * Phase 16 \u2013 Heartbeat stale-state indicator (non-intrusive)\n *\n * Reads window.__HB (from sse-heartbeat-shim) and updates a tiny badge.\n * - Adds a badge to the top-right corner of the dashboard.\n * - Shows OK when both OPS+Tasks have recent heartbeats.\n * - Shows STALE when either stream is missing or old.\n *\n * No coupling to widget internals. Safe to remove.\n */\n(function () {\n  const w = window;\n  const HB = w.__HB;\n\n  function now() {\n    return Date.now();\n  }\n\n  function ms(n) {\n    return Math.max(0, Number(n) || 0);\n  }\n\n  // Consider heartbeats stale after this many ms.\n  const STALE_MS = 15000;\n\n  function fmtAge(ts) {\n    if (!ts) return \"\u2014\";\n    const s = Math.floor((now() - ts) / 1000);\n    return s <= 0 ? \"0s\" : `${s}s`;\n  }\n\n  function ensureBadge() {\n    let el = document.getElementById(\"hb-badge\");\n    if (el) return el;\n\n    el = document.createElement(\"div\");\n    el.id = \"hb-badge\";\n    el.setAttribute(\"role\", \"status\");\n    el.style.position = \"fixed\";\n    el.style.top = \"12px\";\n    el.style.right = \"12px\";\n    el.style.zIndex = \"9999\";\n    el.style.fontFamily = \"ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial\";\n    el.style.fontSize = \"12px\";\n    el.style.padding = \"6px 10px\";\n    el.style.borderRadius = \"999px\";\n    el.style.border = \"1px solid rgba(255,255,255,0.14)\";\n    el.style.background = \"rgba(0,0,0,0.55)\";\n    el.style.backdropFilter = \"blur(6px)\";\n    el.style.webkitBackdropFilter = \"blur(6px)\";\n    el.style.color = \"rgba(255,255,255,0.92)\";\n    el.style.boxShadow = \"0 8px 18px rgba(0,0,0,0.35)\";\n    el.style.userSelect = \"none\";\n    el.style.cursor = \"default\";\n    document.body.appendChild(el);\n    return el;\n  }\n\n  function setState(el, ok) {\n    // No colors specified by instruction in other contexts; keep neutral text-only signal.\n    // We\u2019ll use symbols instead of colored fills.\n    el.textContent = ok\n      ? `HB \u2713 (ops ${fmtAge(HB && HB.get(\"ops\"))}, tasks ${fmtAge(HB && HB.get(\"tasks\"))})`\n      : `HB ! (ops ${fmtAge(HB && HB.get(\"ops\"))}, tasks ${fmtAge(HB && HB.get(\"tasks\"))})`;\n  }\n\n  function tick() {\n    const el = ensureBadge();\n\n    if (!HB || typeof HB.get !== \"function\") {\n      el.textContent = \"HB ? (shim not loaded)\";\n      return;\n    }\n\n    const ops = HB.get(\"ops\");\n    const tasks = HB.get(\"tasks\");\n\n    const opsOk = !!ops && ms(now() - ops) <= STALE_MS;\n    const tasksOk = !!tasks && ms(now() - tasks) <= STALE_MS;\n\n    setState(el, opsOk && tasksOk);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      tick();\n      setInterval(tick, 1000);\n    });\n  } else {\n    tick();\n    setInterval(tick, 1000);\n  }\n})();\n", "/**\n * Phase 21: Task Events SSE listener\n * - Parallel to ops/reflections (does not modify their ownership)\n * - Opens EventSource(\"/events/task-events\")\n * - Buffers events on window.__TASK_EVENTS_FEED and emits DOM event \"task-events:append\"\n * - Tiny debug panel is ALWAYS clickable (collapsed by default)\n *   - Auto-expands when window.__UI_DEBUG or window.__PHASE21_SHOW_TASK_EVENTS is true\n * - Exposes window.__TASK_EVENTS snapshot for quick inspection\n */\n(function () {\n  const URL = \"/events/task-events\";\n  const MAX_ITEMS = 200;\n\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") return;\n  if (window.__TASK_EVENTS_SSE_INITED) return;\n  window.__TASK_EVENTS_SSE_INITED = true;\n\n  function nowIso() {\n    try { return new Date().toISOString(); } catch { return String(Date.now()); }\n  }\n\n  function ensureBuffer() {\n    if (!window.__TASK_EVENTS_FEED) window.__TASK_EVENTS_FEED = [];\n    return window.__TASK_EVENTS_FEED;\n  }\n\n  function ensureSnapshot() {\n    if (!window.__TASK_EVENTS) {\n      window.__TASK_EVENTS = {\n        url: URL,\n        connected: false,\n        lastAt: 0,\n        lastEvent: null,\n        cursor: null,\n        readyState: null,\n      };\n    }\n    return window.__TASK_EVENTS;\n  }\n\n  function pushItem(item) {\n    const buf = ensureBuffer();\n    buf.push(item);\n    if (buf.length > MAX_ITEMS) buf.splice(0, buf.length - MAX_ITEMS);\n\n    const snap = ensureSnapshot();\n    snap.lastAt = item.ts || Date.now();\n    snap.lastEvent = item.event || item.kind || null;\n    if (item?.data && typeof item.data === \"object\" && \"cursor\" in item.data) {\n      snap.cursor = item.data.cursor ?? snap.cursor;\n    }\n    try { snap.readyState = window.__taskEventsES?.readyState ?? null; } catch {}\n\n    try {\n      window.dispatchEvent(new CustomEvent(\"task-events:append\", { detail: item }));\n    } catch {}\n  }\n\n  function safeJson(s) {\n    try { return JSON.parse(s); } catch { return null; }\n  }\n\n  function ensureMiniPanel() {\n    if (document.getElementById(\"task-events-log\")) return;\n\n    const wrap = document.createElement(\"div\");\n    wrap.id = \"task-events-log\";\n    wrap.style.position = \"fixed\";\n    wrap.style.right = \"14px\";\n    wrap.style.bottom = \"14px\";\n    wrap.style.width = \"440px\";\n    wrap.style.maxHeight = \"240px\";\n    wrap.style.overflow = \"hidden\"; // body scrolls, header stays\n    wrap.style.padding = \"10px 12px\";\n    wrap.style.borderRadius = \"12px\";\n    wrap.style.fontFamily = \"ui-monospace, Menlo, Monaco, Consolas, monospace\";\n    wrap.style.fontSize = \"12px\";\n    wrap.style.lineHeight = \"1.35\";\n    wrap.style.zIndex = \"99999\";\n    wrap.style.background = \"rgba(10,10,14,0.72)\";\n    wrap.style.border = \"1px solid rgba(255,255,255,0.12)\";\n    wrap.style.boxShadow = \"0 10px 24px rgba(0,0,0,0.35)\";\n    wrap.style.backdropFilter = \"blur(6px)\";\n    wrap.style.display = \"block\"; // ALWAYS clickable\n\n    const hdr = document.createElement(\"div\");\n    hdr.style.display = \"flex\";\n    hdr.style.alignItems = \"center\";\n    hdr.style.justifyContent = \"space-between\";\n    hdr.style.gap = \"10px\";\n    hdr.style.marginBottom = \"8px\";\n\n    const title = document.createElement(\"div\");\n    title.id = \"task-events-log-title\";\n    title.textContent = \"TASK EVENTS \u00B7 disconnected\";\n    title.style.letterSpacing = \"0.12em\";\n    title.style.fontWeight = \"700\";\n    title.style.opacity = \"0.9\";\n\n    const btn = document.createElement(\"button\");\n    btn.type = \"button\";\n    btn.textContent = \"expand\";\n    btn.style.cursor = \"pointer\";\n    btn.style.border = \"1px solid rgba(255,255,255,0.15)\";\n    btn.style.background = \"rgba(255,255,255,0.08)\";\n    btn.style.color = \"rgba(255,255,255,0.9)\";\n    btn.style.borderRadius = \"10px\";\n    btn.style.padding = \"4px 8px\";\n    btn.style.fontSize = \"12px\";\n\n    const body = document.createElement(\"div\");\n    body.id = \"task-events-log-body\";\n    body.style.maxHeight = \"190px\";\n    body.style.overflow = \"auto\";\n    body.style.display = \"none\"; // collapsed by default\n\n    btn.onclick = () => {\n      const on = body.style.display === \"none\";\n      body.style.display = on ? \"block\" : \"none\";\n      btn.textContent = on ? \"collapse\" : \"expand\";\n    };\n\n    hdr.appendChild(title);\n    hdr.appendChild(btn);\n\n    wrap.appendChild(hdr);\n    wrap.appendChild(body);\n    document.body.appendChild(wrap);\n\n    // Auto-expand when debugging\n    if (window.__UI_DEBUG || window.__PHASE21_SHOW_TASK_EVENTS) {\n      body.style.display = \"block\";\n      btn.textContent = \"collapse\";\n    }\n  }\n\n  function appendLine(text) {\n    const body = document.getElementById(\"task-events-log-body\");\n    if (!body) return;\n    const div = document.createElement(\"div\");\n    div.style.whiteSpace = \"pre-wrap\";\n    div.style.wordBreak = \"break-word\";\n    div.textContent = text;\n    body.appendChild(div);\n    while (body.childNodes.length > 140) body.removeChild(body.firstChild);\n    body.scrollTop = body.scrollHeight;\n  }\n\n  function setHeaderStatus(text) {\n    const t = document.getElementById(\"task-events-log-title\");\n    if (t) t.textContent = text;\n  }\n\n  function start() {\n    ensureMiniPanel();\n    ensureSnapshot();\n\n    const es = new EventSource(URL);\n    window.__taskEventsES = es;\n\n    es.onopen = () => {\n      const snap = ensureSnapshot();\n      snap.connected = true;\n      snap.readyState = es.readyState;\n\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"sse.open\", event: \"open\", url: URL };\n      pushItem(item);\n      setHeaderStatus(\"TASK EVENTS \u00B7 connected\");\n      appendLine(`[${item.iso}] open ${URL}`);\n    };\n\n    es.onerror = () => {\n      const snap = ensureSnapshot();\n      snap.connected = false;\n      snap.readyState = es.readyState;\n\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"sse.error\", event: \"error\", url: URL, readyState: es.readyState };\n      pushItem(item);\n      setHeaderStatus(`TASK EVENTS \u00B7 error (readyState=${es.readyState})`);\n      appendLine(`[${item.iso}] error readyState=${es.readyState}`);\n    };\n\n    // default \"message\"\n    es.onmessage = (ev) => {\n      const payload = safeJson(ev.data);\n      const item = { ts: Date.now(), iso: nowIso(), kind: \"message\", event: \"message\", data: payload ?? ev.data };\n      pushItem(item);\n      appendLine(`[${item.iso}] message :: ${payload ? JSON.stringify(payload) : String(ev.data)}`);\n    };\n\n    // named events (include what server ACTUALLY emits: task.event)\n    const names = [\n      \"hello\",\n      \"heartbeat\",\n      \"task.event\",\n      \"task.lifecycle\",\n      \"task.created\",\n      \"task.updated\",\n      \"task.completed\",\n      \"task.failed\",\n      \"error\",\n    ];\n\n    for (const name of names) {\n      try {\n        es.addEventListener(name, (ev) => {\n          const payload = safeJson(ev.data);\n          const item = { ts: Date.now(), iso: nowIso(), kind: \"event\", event: name, data: payload ?? ev.data };\n          pushItem(item);\n          appendLine(`[${item.iso}] ${name} :: ${payload ? JSON.stringify(payload) : String(ev.data)}`);\n        });\n      } catch {}\n    }\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", start, { once: true });\n  } else {\n    start();\n  }\n})();\n", "/**\n * Phase 16: Dashboard wiring for OPS + Reflections SSE streams.\n *\n * - Consume /events/ops + /events/reflections via EventSource\n * - Treat *.state as \"initial paint\" (replace baseline state)\n * - Treat subsequent events as incremental updates (merge / patch)\n * - Add tiny \u201Cconnected / last event\u201D UI indicator for each stream\n *\n * NOTE: Your SSE server emits NAMED events (e.g. \"ops.state\", \"reflections.state\").\n * EventSource.onmessage only receives UNNAMED events, so we must addEventListener()\n * for the named event types we care about.\n */\n\n(() => {\n  \"use strict\";\n\n  const OPS_SSE_URL = \"/events/ops\";\n  const REFLECTIONS_SSE_URL = \"/events/reflections\";\n\n  const NOW = () => Date.now();\n\n  function safeJsonParse(s) {\n    try { return JSON.parse(s); } catch { return null; }\n  }\n\n  function formatAge(ms) {\n    if (!Number.isFinite(ms)) return \"\u2014\";\n    const s = Math.floor(ms / 1000);\n    if (s < 60) return `${s}s`;\n    const m = Math.floor(s / 60);\n    if (m < 60) return `${m}m`;\n    return `${Math.floor(m / 60)}h`;\n  }\n\n  function el(tag, attrs = {}, text = \"\") {\n    const n = document.createElement(tag);\n    for (const [k, v] of Object.entries(attrs)) {\n      if (k === \"class\") n.className = v;\n      else if (k === \"style\") n.setAttribute(\"style\", v);\n      else n.setAttribute(k, v);\n    }\n    if (text) n.textContent = text;\n    return n;\n  }\n\n  function ensureStyles() {\n    if (document.getElementById(\"phase16-sse-style\")) return;\n    const s = el(\"style\", { id: \"phase16-sse-style\" });\n    s.textContent = `\n      .sse-indicator {\n        display:inline-flex;\n        align-items:center;\n        gap:6px;\n        font-size:11px;\n        line-height:1;\n        opacity:.85;\n        user-select:none;\n        white-space:nowrap;\n      }\n      .sse-indicator .dot {\n        width:7px; height:7px; border-radius:999px;\n        background:#555;\n        box-shadow:0 0 0 1px rgba(255,255,255,.08) inset;\n      }\n      .sse-indicator[data-connected=\"true\"] .dot { background:#2dd4bf; }\n      .sse-indicator[data-connected=\"false\"] .dot { background:#f97316; }\n      .sse-indicator .meta { font-variant-numeric: tabular-nums; }\n    `;\n    document.head.appendChild(s);\n  }\n\n  function mount(anchor, id, label) {\n    ensureStyles();\n\n    if (!anchor) {\n      let tray = document.getElementById(\"phase16-sse-tray\");\n      if (!tray) {\n        tray = el(\"div\", {\n          id: \"phase16-sse-tray\",\n          style: [\n            \"position:fixed\",\n            \"left:10px\",\n            \"bottom:10px\",\n            \"display:flex\",\n            \"flex-direction:column\",\n            \"gap:6px\",\n            \"z-index:9999\",\n            \"pointer-events:none\",\n          ].join(\";\")\n        });\n        document.body.appendChild(tray);\n      }\n      anchor = tray;\n    }\n\n    let node = document.getElementById(id);\n    if (node) return node;\n\n    node = el(\"span\", { id, class: \"sse-indicator\", \"data-connected\": \"false\" });\n    node.append(\n      el(\"span\", { class: \"dot\", \"aria-hidden\": \"true\" }),\n      el(\"span\", { class: \"meta\" }, `${label}: disconnected \u00B7 last: \u2014`)\n    );\n\n    // try to place nicely; otherwise append\n    try {\n      if (anchor.matches && anchor.matches(\"header,h1,h2,h3,h4,strong\")) {\n        const wrap = el(\"span\", { style: \"margin-left:8px\" });\n        wrap.appendChild(node);\n        anchor.appendChild(wrap);\n      } else {\n        const wrap = el(\"div\", { style: \"margin-top:4px\" });\n        wrap.appendChild(node);\n        anchor.appendChild(wrap);\n      }\n    } catch {\n      anchor.appendChild(node);\n    }\n\n    return node;\n  }\n\n  function set(ind, label, connected, lastAt) {\n    if (!ind) return;\n    ind.dataset.connected = connected ? \"true\" : \"false\";\n    const meta = ind.querySelector(\".meta\");\n    if (!meta) return;\n    meta.textContent = `${label}: ${connected ? \"connected\" : \"disconnected\"} \u00B7 last: ${lastAt ? formatAge(NOW() - lastAt) : \"\u2014\"}`;\n  }\n\n  function ensureGlobal() {\n    window.__MB_STREAMS ||= {\n      ops: { connected: false, lastAt: 0, state: {}, es: null },\n      reflections: { connected: false, lastAt: 0, state: {}, es: null },\n    };\n    return window.__MB_STREAMS;\n  }\n\n  function shallowMerge(target, patch) {\n    if (!target || typeof target !== \"object\") target = {};\n    if (!patch || typeof patch !== \"object\") return target;\n    return Object.assign(target, patch);\n  }\n\n  // Minimal dot-path patch support: { path:\"a.b.c\", value:any }\n  function applyDotPathPatch(state, patch) {\n    if (!state || typeof state !== \"object\") state = {};\n    const path = patch && typeof patch.path === \"string\" ? patch.path : \"\";\n    if (!path) return state;\n    const parts = path.split(\".\").filter(Boolean);\n    if (!parts.length) return state;\n    let cur = state;\n    for (let i = 0; i < parts.length - 1; i++) {\n      const k = parts[i];\n      if (!cur[k] || typeof cur[k] !== \"object\") cur[k] = {};\n      cur = cur[k];\n    }\n    cur[parts[parts.length - 1]] = patch.value;\n    return state;\n  }\n\n  function isStateEvent(evtType, parsed) {\n    if (typeof evtType === \"string\" && evtType.endsWith(\".state\")) return true;\n    if (parsed && typeof parsed === \"object\") {\n      if (parsed.state && typeof parsed.state === \"object\") return true;\n      if (typeof parsed.type === \"string\" && parsed.type.includes(\"state\")) return true;\n      if (typeof parsed.event === \"string\" && parsed.event.includes(\"state\")) return true;\n    }\n    return false;\n  }\n\n  function extractPayload(parsed) {\n    if (!parsed || typeof parsed !== \"object\") return parsed;\n    if (parsed.payload !== undefined) return parsed.payload;\n    if (parsed.data !== undefined) return parsed.data;\n    if (parsed.delta !== undefined) return parsed.delta;\n    if (parsed.patch !== undefined) return parsed.patch;\n    if (parsed.state !== undefined) return parsed.state;\n    return parsed;\n  }\n\n  function connect(key, label, url, ind) {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) {\n    return null;\n  }\n\n    const g = ensureGlobal();\n\n    // close any existing connection\n    try { g[key].es && g[key].es.close(); } catch {}\n    g[key].es = null;\n\n    const es = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(url));\n    g[key].es = es;\n\n\n    // Phase16: guard null EventSource before handlers\n    if (!es) return null;\n\n    const tick = () => set(ind, label, g[key].connected, g[key].lastAt);\n\n    es.onopen = () => { g[key].connected = true; tick(); };\n    es.onerror = () => { g[key].connected = false; tick(); };\n\n    const handle = (evtType, e) => {\n      g[key].lastAt = NOW();\n\n      const parsed = safeJsonParse(e && e.data ? e.data : \"\");\n      const payload = extractPayload(parsed);\n\n      if (isStateEvent(evtType, parsed)) {\n        // initial paint: replace\n        g[key].state = (payload && typeof payload === \"object\") ? payload : { value: payload };\n      } else {\n        // incremental: patch or merge\n        if (payload && typeof payload === \"object\") {\n          if (typeof payload.path === \"string\" && \"value\" in payload) {\n            g[key].state = applyDotPathPatch(g[key].state, payload);\n          } else {\n            g[key].state = shallowMerge(g[key].state, payload);\n          }\n        } else if (payload !== null && payload !== undefined) {\n          g[key].state = shallowMerge(g[key].state, { lastValue: payload });\n        }\n      }\n\n      tick();\n      try {\n        window.dispatchEvent(new CustomEvent(`mb:${key}:update`, {\n          detail: { event: evtType, state: g[key].state, raw: parsed }\n        }));\n      } catch {}\n    };\n\n    // Unnamed events (rare in your streams, but safe)\n    es.onmessage = (e) => handle(\"message\", e);\n\n    // Named events (your streams DO emit these)\n    const eventNames = [\n      \"hello\",\n      `${key}.state`,\n      `${key}.update`,\n      `${key}.patch`,\n      `${key}.delta`,\n      \"state\",\n      \"update\",\n      \"patch\",\n      \"delta\",\n    ];\n\n    for (const name of eventNames) {\n      try {\n        es.addEventListener(name, (e) => handle(name, e));\n      } catch {}\n    }\n\n    tick();\n  }\n\n  function findOpsAnchor() {\n    return (\n      document.getElementById(\"ops-pill\") ||\n      document.querySelector(\"[data-widget='ops-pill']\") ||\n      document.querySelector(\".ops-pill\") ||\n      document.querySelector(\"#ops\") ||\n      null\n    );\n  }\n\n  function findReflectionsAnchor() {\n    return (\n      document.getElementById(\"reflections-header\") ||\n      document.getElementById(\"reflections\") ||\n      document.querySelector(\"[data-panel='reflections']\") ||\n      document.querySelector(\".reflections\") ||\n      (() => {\n        const heads = Array.from(document.querySelectorAll(\"h1,h2,h3,h4,header,strong\"));\n        return heads.find(h => (h.textContent || \"\").toLowerCase().includes(\"reflections\")) || null;\n      })()\n    );\n  }\n\n  function boot() {\n    const opsInd = mount(findOpsAnchor(), \"ops-sse-indicator\", \"OPS SSE\");\n    const refInd = mount(findReflectionsAnchor(), \"reflections-sse-indicator\", \"Reflections SSE\");\n\n    connect(\"ops\", \"OPS SSE\", OPS_SSE_URL, opsInd);\n    connect(\"reflections\", \"Reflections SSE\", REFLECTIONS_SSE_URL, refInd);\n\n    // keep age ticking\n    setInterval(() => {\n      const g = ensureGlobal();\n      set(opsInd, \"OPS SSE\", g.ops.connected, g.ops.lastAt);\n      set(refInd, \"Reflections SSE\", g.reflections.connected, g.reflections.lastAt);\n    }, 1000);\n  }\n\n  document.readyState === \"loading\"\n    ? document.addEventListener(\"DOMContentLoaded\", boot, { once: true })\n    : boot();\n})();\n\n// PHASE16_CONNECT_GUARD_FIXED_1767139733\n", "// <0001fb02> Agent Status Row \u2013 live heartbeats from OPS SSE\n// - Renders status pills for Matilda, Cade, Effie, Atlas\n// - Listens to OPS SSE on port 3201\n// - Updates colors/text based on incoming status\n\n(() => {\n  const container = document.getElementById(\"agent-status-container\");\n  if (!container) {\n    console.warn(\"agent-status-row.js: #agent-status-container not found.\");\n    return;\n  }\n\n  // Clear placeholder text (e.g., \"Loading agents...\")\n  container.innerHTML = \"\";\n\n  const AGENTS = [\"Matilda\", \"Cade\", \"Effie\", \"Atlas\"];\n  const indicators = {};\n\n  const row = document.createElement(\"div\");\n  row.className = \"flex flex-wrap gap-4 items-center\";\n  container.appendChild(row);\n\n  AGENTS.forEach((name) => {\n    const pill = document.createElement(\"div\");\n    pill.className =\n      \"px-3 py-1 rounded-full bg-gray-700 text-sm flex items-center gap-2 shadow\";\n\n    const dot = document.createElement(\"span\");\n    dot.className = \"w-2 h-2 rounded-full bg-yellow-400\";\n\n    const label = document.createElement(\"span\");\n    label.textContent = `${name}: \u23F3`;\n\n    pill.dataset.agent = name.toLowerCase();\n    pill.append(dot, label);\n    row.appendChild(pill);\n\n    indicators[name.toLowerCase()] = { pill, dot, label };\n  });\n\n  const OPS_SSE_URL = `/events/ops`;\n  \n\n  const __DISABLE_OPTIONAL_SSE = (typeof window !== \"undefined\" && window.__DISABLE_OPTIONAL_SSE) === true;\n  if (__DISABLE_OPTIONAL_SSE) {\n    console.warn(\"[agent-status-row] Optional SSE disabled (Phase 16 pending):\", OPS_SSE_URL);\n    Object.keys(indicators).forEach((key) => applyVisual(key, \"unknown\"));\n    return;\n  }\nlet source;\n\n  try {\n    source = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(OPS_SSE_URL));\n  } catch (err) {\n    console.error(\"agent-status-row.js: Failed to open OPS SSE connection:\", err);\n    return;\n  }\n\n  function classifyStatus(statusString) {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) {\n    return null;\n  }\n\n    const s = (statusString || \"\").toLowerCase();\n    if (!s) return \"unknown\";\n    if (s.includes(\"error\") || s.includes(\"failed\") || s.includes(\"offline\")) {\n      return \"error\";\n    }\n    if (s.includes(\"online\") || s.includes(\"ready\") || s.includes(\"ok\")) {\n      return \"online\";\n    }\n    if (s.includes(\"queued\") || s.includes(\"pending\") || s.includes(\"init\")) {\n      return \"pending\";\n    }\n    return \"unknown\";\n  }\n\n  function applyVisual(agentKey, statusString) {\n    const indicator = indicators[agentKey];\n    if (!indicator) return;\n\n    const kind = classifyStatus(statusString);\n    const { pill, dot, label } = indicator;\n\n    // Reset base classes\n    dot.className = \"w-2 h-2 rounded-full\";\n    pill.classList.remove(\"border\", \"border-red-400\", \"border-green-400\", \"border-yellow-300\");\n\n    switch (kind) {\n      case \"online\":\n        dot.classList.add(\"bg-green-400\");\n        pill.classList.add(\"border\", \"border-green-400\");\n        break;\n      case \"error\":\n        dot.classList.add(\"bg-red-400\");\n        pill.classList.add(\"border\", \"border-red-400\");\n        break;\n      case \"pending\":\n        dot.classList.add(\"bg-yellow-300\");\n        pill.classList.add(\"border\", \"border-yellow-300\");\n        break;\n      case \"unknown\":\n      default:\n        dot.classList.add(\"bg-gray-500\");\n        break;\n    }\n\n    const prettyName = agentKey.charAt(0).toUpperCase() + agentKey.slice(1);\n    const finalStatus = statusString || \"unknown\";\n    label.textContent = `${prettyName}: ${finalStatus}`;\n  }\n\n  // Phase16: guard null EventSource before handlers\n  if (!source) return null;\n  source.onmessage = (event) => {\n    let payloadRaw = event.data;\n    let data;\n\n    try {\n      data = JSON.parse(payloadRaw);\n    } catch {\n      // If it's not JSON, ignore for agent-status purposes\n      return;\n    }\n\n    const agentName =\n      (data.agent || data.actor || data.source || data.worker || \"\").toString();\n    if (!agentName) return;\n\n    const key = agentName.toLowerCase();\n    if (!indicators[key]) {\n      // Ignore agents we don't show in the row\n      return;\n    }\n\n    const status = (data.status || data.state || data.level || \"\").toString() || \"unknown\";\n    applyVisual(key, status);\n  };\n\n  source.onerror = (err) => {\n    console.warn(\"agent-status-row.js: OPS SSE error:\", err);\n    // On error, show all as unknown (neutral gray)\n    Object.keys(indicators).forEach((key) => applyVisual(key, \"unknown\"));\n  };\n})();\n", "// <0001fad7> Phase 5.1 \u2014 Matilda \u2192 Cade \u2192 Effie Broadcast Visualization\n// Wrapped in a guarded init() so we don't create duplicate intervals on reload.\n\nconst BROADCAST_GUARD_KEY = \"__broadcastVisualizationInited\";\n\nconst nodes = [\"Matilda\", \"Cade\", \"Effie\"];\n\nfunction renderBroadcastNodes() {\nconst container = document.getElementById(\"broadcast-visual\");\nif (!container) return;\n\nconst parts = [];\nfor (let i = 0; i < nodes.length; i++) {\nconst n = nodes[i];\nparts.push('<div class=\"node\" id=\"node-' + n + '\">' + n + \"</div>\");\nif (i < nodes.length - 1) {\nparts.push('<div class=\"arrow\">\u279C</div>');\n}\n}\ncontainer.innerHTML = parts.join(\"\");\n}\n\nfunction startBroadcastCycle() {\nlet idx = 0;\n\nsetInterval(() => {\nconst allNodes = document.querySelectorAll(\".node\");\nallNodes.forEach((n) => n.classList.remove(\"active\"));\n\nconst activeId = \"node-\" + nodes[idx];\nconst active = document.getElementById(activeId);\nif (active) active.classList.add(\"active\");\n\nidx = (idx + 1) % nodes.length;\n\n}, 1500);\n}\n\n/**\n\n* Initialize the broadcast visualization in a guarded way so it\n* does not re-register intervals or duplicate DOM nodes.\n  */\n  export function initBroadcastVisualization() {\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") {\n  return;\n  }\n\nif (window[BROADCAST_GUARD_KEY]) {\nreturn;\n}\nwindow[BROADCAST_GUARD_KEY] = true;\n\nconst run = () => {\nrenderBroadcastNodes();\nstartBroadcastCycle();\n};\n\nif (document.readyState === \"loading\") {\nwindow.addEventListener(\"DOMContentLoaded\", run);\n} else {\nrun();\n}\n}\n\n// Optional: expose for manual debugging in the browser console\nif (typeof window !== \"undefined\") {\nwindow.initBroadcastVisualization = initBroadcastVisualization;\n}\n", "// public/js/ops-status-widget.js\n// Phase 11: minimal pill ID normalizer; all state comes from ops-pill-state.js\n(function () {\n  if (typeof document === \"undefined\") return;\n\n  var existing = document.getElementById(\"ops-dashboard-pill\");\n  if (existing) return;\n\n  var pill = document.querySelector(\"[data-ops-pill]\");\n  if (!pill) return;\n\n  pill.id = \"ops-dashboard-pill\";\n})();\n", "// Lightweight OPS SSE \u2192 global state bridge for Phase 11\n(() => {\n  // Phase16: bail if SSE owner already started\n  if (typeof window !== \"undefined\" && window.__PHASE16_SSE_OWNER_STARTED) return;\n\n  if (typeof window === \"undefined\" || typeof EventSource === \"undefined\") return;\n\n  // Avoid multiple initializations if bundle is loaded twice\n  if (window.__opsGlobalsBridgeInitialized) return;\n  window.__opsGlobalsBridgeInitialized = true;\n\n  // Initialize globals if they don't exist\n  if (typeof window.lastOpsHeartbeat === \"undefined\") {\n    window.lastOpsHeartbeat = null;\n  }\n  if (typeof window.lastOpsStatusSnapshot === \"undefined\") {\n    window.lastOpsStatusSnapshot = null;\n  }\n\n  const opsUrl = `/events/ops`;\n\n  \n\n  const __DISABLE_OPTIONAL_SSE = (typeof window !== \"undefined\" && window.__DISABLE_OPTIONAL_SSE) === true;\n  if (__DISABLE_OPTIONAL_SSE) {\n    console.warn(\"[ops-globals-bridge] Optional SSE disabled (Phase 16 pending):\", opsUrl);\n    return;\n  }\nconst handleEvent = (event) => {\n    try {\n      const data = JSON.parse(event.data || \"null\");\n      if (!data) return;\n\n      window.lastOpsHeartbeat = Math.floor(Date.now() / 1000);\n      window.lastOpsStatusSnapshot = data;\n    } catch (err) {\n      console.warn(\"[ops-globals-bridge] Failed to parse OPS event:\", err);\n    }\n  \n  // Phase16: emit a unified CustomEvent for OPS pill + listeners\n  try {\n    window.dispatchEvent(new CustomEvent(\"mb:ops:update\", {\n      detail: { event: \"message\", state: window.lastOpsStatusSnapshot }\n    }));\n  } catch {}\n};\n\n  try {\n    const es = (window.__PHASE16_SSE_OWNER_STARTED ? null : new EventSource(opsUrl));\n\n    // Default unnamed \"message\" events (if any in future)\n    // Phase16: guard null EventSource before handlers\n\n    if (!es) return null;\n\n    es.onmessage = handleEvent;\n\n    // Named \"hello\" events from OPS SSE\n    es.addEventListener(\"hello\", handleEvent);\n\n    // Phase16: guard null EventSource before handlers (onerror)\n\n    if (!es) return;\n\n    es.onerror = (err) => {\n      console.warn(\"[ops-globals-bridge] EventSource error:\", err);\n    };\n  } catch (err) {\n    console.warn(\"[ops-globals-bridge] Failed to init EventSource:\", err);\n  }\n})();\n", "// public/js/ops-pill-state.js\n// Phase 11: simple dashboard OPS pill driven by lastOpsHeartbeat.\n// - Creates #ops-dashboard-pill on /dashboard if missing.\n// - Hides any external #ops-status-pill overlay.\n// - Shows \"OPS: Unknown\" / \"OPS: Online\" based on heartbeat.\n\n(function () {\n  if (typeof window === \"undefined\" || typeof document === \"undefined\") return;\n  if (window.location.pathname !== \"/dashboard\") return;\n\n  var POLL_INTERVAL_MS = 5000;\n  var PILL_ID = \"ops-dashboard-pill\";\n\n  function ensurePill() {\n    var pill = document.getElementById(PILL_ID);\n    if (pill) return pill;\n\n    // Create the dashboard pill near the top of the body\n    pill = document.createElement(\"span\");\n    pill.id = PILL_ID;\n    pill.className = \"ops-pill ops-pill-unknown\";\n    pill.textContent = \"OPS: Unknown\";\n\n    // Keep styling minimal; main styles come from CSS class\n    pill.style.display = \"inline-block\";\n\n    if (document.body.firstChild) {\n      document.body.insertBefore(pill, document.body.firstChild);\n    } else {\n      document.body.appendChild(pill);\n    }\n\n    return pill;\n  }\n\n  function applyState() {\n    // Always hide any external overlay pill if present\n    var overlay = document.getElementById(\"ops-status-pill\");\n    if (overlay) {\n      overlay.style.display = \"none\";\n    }\n\n    var pill = ensurePill();\n    if (!pill) return;\n\n    var hasHeartbeat = (typeof window.lastOpsHeartbeat === \"number\");\n\n    var label = hasHeartbeat ? \"OPS: Online\"  : \"OPS: Unknown\";\n    var cls   = hasHeartbeat ? \"ops-pill-online\" : \"ops-pill-unknown\";\n\n    pill.classList.remove(\n      \"ops-pill-unknown\",\n      \"ops-pill-online\",\n      \"ops-pill-stale\",\n      \"ops-pill-error\"\n    );\n    pill.classList.add(cls);\n    pill.textContent = label;\n  }\n\n  applyState();\n  setInterval(applyState, POLL_INTERVAL_MS);\n})();\n", "/**\n * Tasks Widget (stable, no SSE)\n * - GET /api/tasks\n * - POST /api/complete-task\n * - No optimistic removal (prevents list blinking)\n */\n(() => {\n  const API = {\n    list: \"/api/tasks\",\n    complete: \"/api/complete-task\",\n  };\n\n  const SELECTORS = [\n    \"#tasks-widget\",\n    \"#tasksWidget\",\n    \"[data-tasks-widget]\",\n    \"[data-widget='tasks']\",\n  ];\n\n  const state = {\n    tasks: [],\n    loading: false,\n    lastError: null,\n    inflightComplete: new Set(),\n  };\n\n  function $(sel, root = document) {\n    return root.querySelector(sel);\n  }\n\n  function findMount() {\n    for (const sel of SELECTORS) {\n      const el = $(sel);\n      if (el) return el;\n    }\n    return null;\n  }\n\n  function esc(s) {\n    return String(s ?? \"\")\n      .replaceAll(\"&\", \"&amp;\")\n      .replaceAll(\"<\", \"&lt;\")\n      .replaceAll(\">\", \"&gt;\")\n      .replaceAll('\"', \"&quot;\")\n      .replaceAll(\"'\", \"&#39;\");\n  }\n\n  async function apiJson(url, opts = {}) {\n    const res = await fetch(url, {\n      method: opts.method || \"GET\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: opts.body ? JSON.stringify(opts.body) : undefined,\n    });\n    const json = await res.json();\n    if (!res.ok) throw new Error(json?.error || \"Request failed\");\n    return json;\n  }\n\n  async function fetchTasks() {\n    state.loading = true;\n    render();\n    try {\n      const data = await apiJson(API.list);\n      state.tasks = (data.tasks || []).map(t => ({\n        id: String(t.id),\n        title: t.title || \"\",\n        status: t.status || \"\",\n      }));\n    } catch (e) {\n      state.lastError = e.message;\n    } finally {\n      state.loading = false;\n      render();\n    }\n  }\n\n  async function completeTask(taskId) {\n    if (state.inflightComplete.has(taskId)) return;\n    state.inflightComplete.add(taskId);\n    render();\n\n    try {\n      await apiJson(API.complete, {\n        method: \"POST\",\n        body: { taskId },\n      });\n    } catch (e) {\n      state.lastError = e.message;\n    } finally {\n      state.inflightComplete.delete(taskId);\n      await fetchTasks();\n    }\n  }\n\n  function render() {\n    const mount = findMount();\n    if (!mount) return;\n\n    mount.innerHTML = `\n      <div>\n        \n        ${state.lastError ? `<div style=\"color:red\">${esc(state.lastError)}</div>` : \"\"}\n        <div>\n          ${state.tasks.map(t => `\n            <div style=\"display:flex;justify-content:space-between;gap:8px\">\n              <span>${esc(t.title)}</span>\n              ${\n                ([\"complete\",\"completed\",\"done\"].includes(String(t.status||\"\").toLowerCase()))\n                  ? `<span style=\"opacity:.5;font-size:12px\">Completed</span>`\n                  : `<button data-id=\"${t.id}\">Complete</button>`\n              }\n            </div>\n          `).join(\"\")}\n        </div>\n      </div>\n    `;\n\n    mount.querySelectorAll(\"button[data-id]\").forEach(btn => {\n      btn.onclick = () => completeTask(btn.dataset.id);\n    });\n  }\n\n  document.addEventListener(\"DOMContentLoaded\", fetchTasks);\n\n  // Phase22: SSE-driven refresh (ignore heartbeats)\n  window.addEventListener(\"mb.task.event\", (e) => {\n    const k = String(e?.detail?.kind || e?.detail?.type || \"\");\n    if (k === \"heartbeat\") return;\n    fetchTasks();\n  });\n\n// Phase22: SSE-driven refresh\n  window.addEventListener(\"mb.task.event\", () => { fetchTasks(); });\n\n// Auto-refresh (no SSE): keep widget feeling live\n  setInterval(() => { fetchTasks(); }, 5000);\n\n})();\n", "(function () {\n  function log(msg) {\n    console.log(\"[matilda-chat]\", msg);\n  }\n\n  function appendMessage(transcriptEl, sender, text) {\n    if (!transcriptEl) return;\n    var line = document.createElement(\"p\");\n    line.className = \"mb-1 text-sm\";\n    var label = sender ? sender + \": \" : \"\";\n    line.textContent = label + text;\n    transcriptEl.appendChild(line);\n    transcriptEl.scrollTop = transcriptEl.scrollHeight;\n  }\n\n  function setSendingState(sendBtn, input, isSending) {\n    if (sendBtn) {\n      sendBtn.disabled = isSending;\n      sendBtn.classList.toggle(\"opacity-60\", isSending);\n      sendBtn.textContent = isSending ? \"Sending...\" : \"Send\";\n    }\n    if (input) {\n      input.disabled = isSending;\n    }\n  }\n\n  async function wireChat() {\n    var root = document.getElementById(\"matilda-chat-root\");\n    if (!root) {\n      log(\"No #matilda-chat-root found; skipping wiring.\");\n      return;\n    }\n\n    var transcript = document.getElementById(\"matilda-chat-transcript\");\n    var input = document.getElementById(\"matilda-chat-input\");\n    var sendBtn = document.getElementById(\"matilda-chat-send\");\n\n    if (!transcript || !input || !sendBtn) {\n      log(\"Missing one or more Matilda chat elements; aborting wiring.\");\n      return;\n    }\n\n    function safeTrim(value) {\n      return (value || \"\").toString().trim();\n    }\n\n    async function handleSend() {\n      var message = safeTrim(input.value);\n      if (!message) return;\n\n      appendMessage(transcript, \"You\", message);\n      input.value = \"\";\n      setSendingState(sendBtn, input, true);\n\n      try {\n        var res = await fetch(\"/api/chat\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({ message: message, agent: \"matilda\" }),\n        });\n\n        if (!res.ok) {\n          appendMessage(\n            transcript,\n            \"Matilda\",\n            \"(error talking to /api/chat)\"\n          );\n          return;\n        }\n\n        var data = await res.json();\n        var reply =\n          (data && (data.reply || data.message || data.response)) ||\n          \"(no reply)\";\n        appendMessage(transcript, \"Matilda\", reply);\n      } catch (err) {\n        console.error(err);\n        appendMessage(transcript, \"Matilda\", \"(network error)\");\n      } finally {\n        setSendingState(sendBtn, input, false);\n      }\n    }\n\n    sendBtn.addEventListener(\"click\", handleSend);\n\n    var quickBtn = document.getElementById(\"matilda-chat-quick-check\");\n    if (quickBtn) {\n      quickBtn.addEventListener(\"click\", function () {\n        input.value = \"Quick systems check from dashboard Phase 11.4.\";\n        handleSend();\n      });\n    }\n\n    input.addEventListener(\"keydown\", function (e) {\n      if (e.key === \"Enter\" && !e.shiftKey) {\n        e.preventDefault();\n        handleSend();\n      }\n    });\n\n    log(\"Matilda chat wiring complete.\");\n  }\n\n  document.addEventListener(\"DOMContentLoaded\", wireChat);\n})();\n", "(() => {\n  const SSE_URL = \"/events/task-events\";\n\n  const PANEL_ID = \"mb-task-events-panel\";\n  const FEED_ID = \"mb-task-events-feed\";\n  const COUNTS_ID = \"mb-task-events-counts\";\n  const ANCHOR_ID = \"mb-task-events-panel-anchor\";\n\n  function mountRoot() {\n    const anchor = document.getElementById(ANCHOR_ID);\n    if (anchor) return anchor;\n    return document.body;\n  }\n\n  function ensurePanel() {\n    if (document.getElementById(PANEL_ID)) return;\n\n    const root = mountRoot();\n\n    const panel = document.createElement(\"div\");\n    panel.id = PANEL_ID;\n\n    // If anchored, behave like an in-page card; otherwise float.\n    const anchored = root && root.id === ANCHOR_ID;\n\n    panel.style.width = anchored ? \"100%\" : \"360px\";\n    panel.style.maxWidth = anchored ? \"100%\" : \"calc(100vw - 24px)\";\n    panel.style.maxHeight = anchored ? \"260px\" : \"40vh\";\n    panel.style.overflow = \"hidden\";\n    panel.style.zIndex = \"9999\";\n    panel.style.border = \"1px solid rgba(255,255,255,0.12)\";\n    panel.style.borderRadius = \"14px\";\n    panel.style.background = \"rgba(10,10,14,0.92)\";\n    panel.style.backdropFilter = \"blur(10px)\";\n    panel.style.boxShadow = \"0 10px 30px rgba(0,0,0,0.35)\";\n    panel.style.color = \"rgba(255,255,255,0.92)\";\n    panel.style.fontFamily =\n      \"ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace\";\n\n    if (!anchored) {\n      panel.style.position = \"fixed\";\n      panel.style.right = \"12px\";\n      panel.style.bottom = \"12px\";\n    } else {\n      panel.style.marginTop = \"12px\";\n    }\n\n    const header = document.createElement(\"div\");\n    header.style.display = \"flex\";\n    header.style.alignItems = \"center\";\n    header.style.justifyContent = \"space-between\";\n    header.style.gap = \"8px\";\n    header.style.padding = \"10px 12px\";\n    header.style.borderBottom = \"1px solid rgba(255,255,255,0.10)\";\n\n    const title = document.createElement(\"div\");\n    title.textContent = \"TASK EVENTS (live)\";\n    title.style.fontSize = \"12px\";\n    title.style.letterSpacing = \"0.08em\";\n    title.style.opacity = \"0.9\";\n\n    const right = document.createElement(\"div\");\n    right.style.display = \"flex\";\n    right.style.alignItems = \"center\";\n    right.style.gap = \"10px\";\n\n    const counts = document.createElement(\"div\");\n    counts.id = COUNTS_ID;\n    counts.textContent = \"created:0  completed:0  failed:0\";\n    counts.style.fontSize = \"11px\";\n    counts.style.opacity = \"0.85\";\n\n    const dot = document.createElement(\"span\");\n    dot.setAttribute(\"aria-label\", \"task-events connection\");\n    dot.title = \"task-events connection\";\n    dot.style.display = \"inline-block\";\n    dot.style.width = \"10px\";\n    dot.style.height = \"10px\";\n    dot.style.borderRadius = \"999px\";\n    dot.style.background = \"rgba(255,255,255,0.25)\";\n    dot.style.boxShadow = \"0 0 0 2px rgba(255,255,255,0.08) inset\";\n\n    const btn = document.createElement(\"button\");\n    btn.type = \"button\";\n    btn.textContent = \"\u00D7\";\n    btn.title = \"hide\";\n    btn.style.cursor = \"pointer\";\n    btn.style.border = \"1px solid rgba(255,255,255,0.14)\";\n    btn.style.background = \"transparent\";\n    btn.style.color = \"rgba(255,255,255,0.85)\";\n    btn.style.borderRadius = \"10px\";\n    btn.style.width = \"28px\";\n    btn.style.height = \"24px\";\n    btn.style.lineHeight = \"22px\";\n    btn.style.fontSize = \"14px\";\n    btn.onclick = () => panel.remove();\n\n    right.appendChild(dot);\n    right.appendChild(counts);\n    right.appendChild(btn);\n\n    header.appendChild(title);\n    header.appendChild(right);\n\n    const feed = document.createElement(\"div\");\n    feed.id = FEED_ID;\n    feed.style.padding = \"10px 12px\";\n    feed.style.overflow = \"auto\";\n    feed.style.maxHeight = anchored ? \"200px\" : \"calc(40vh - 46px)\";\n\n    panel.appendChild(header);\n    panel.appendChild(feed);\n\n    root.appendChild(panel);\n\n    window.__MB_TASK_EVENTS_PANEL = { dot, feed, counts };\n    console.log(\"[phase22] task-events panel mounted (anchored=%s)\", anchored);\n  }\n\n  function setDot(state) {\n    ensurePanel();\n    const dot = window.__MB_TASK_EVENTS_PANEL?.dot;\n    if (!dot) return;\n    if (state === \"open\") dot.style.background = \"rgba(80,200,120,0.85)\";\n    else if (state === \"error\") dot.style.background = \"rgba(240,90,90,0.85)\";\n    else dot.style.background = \"rgba(255,255,255,0.25)\";\n  }\n\n  const seen = new Set();\n  const tally = { created: 0, completed: 0, failed: 0 };\n\n  function bumpCounts(kind) {\n    if (kind === \"task.created\") tally.created += 1;\n    if (kind === \"task.completed\") tally.completed += 1;\n    if (kind === \"task.failed\") tally.failed += 1;\n\n    const el = document.getElementById(COUNTS_ID);\n    if (el) el.textContent = `created:${tally.created}  completed:${tally.completed}  failed:${tally.failed}`;\n  }\n\n  function formatLine(ev, fallbackKind) {\n    const ts = typeof ev.ts === \"number\" ? new Date(ev.ts).toISOString() : new Date().toISOString();\n    const tid = ev.task_id ?? ev.id ?? ev.taskId ?? \"unknown\";\n    const run = ev.run_id ?? ev.runId ?? \"\";\n    const msg = ev.msg ?? ev.message ?? \"\";\n    const extras = [];\n    if (run) extras.push(`run=${run}`);\n    if (ev.actor) extras.push(`actor=${ev.actor}`);\n    if (ev.status) extras.push(`status=${ev.status}`);\n    if (typeof ev.cursor === \"number\") extras.push(`cursor=${ev.cursor}`);\n    const extraStr = extras.length ? ` (${extras.join(\" \")})` : \"\";\n    return `${ts}  ${(ev.kind ?? fallbackKind ?? \"event\")}  task=${tid}${extraStr}${msg ? \" \u2014 \" + msg : \"\"}`;\n  }\n\n  function appendLine(text, kind) {\n    ensurePanel();\n    const feed = document.getElementById(FEED_ID);\n    if (!feed) return;\n\n    const row = document.createElement(\"div\");\n    row.style.whiteSpace = \"pre-wrap\";\n    row.style.wordBreak = \"break-word\";\n    row.style.fontSize = \"11px\";\n    row.style.lineHeight = \"1.35\";\n    row.style.padding = \"6px 8px\";\n    row.style.border = \"1px solid rgba(255,255,255,0.10)\";\n    row.style.borderRadius = \"12px\";\n    row.style.marginBottom = \"8px\";\n    row.style.background = \"rgba(255,255,255,0.03)\";\n\n    if (kind === \"task.completed\") row.style.borderColor = \"rgba(80,200,120,0.35)\";\n    if (kind === \"task.failed\") row.style.borderColor = \"rgba(240,90,90,0.35)\";\n    if (kind === \"heartbeat\") row.style.opacity = \"0.65\";\n\n    row.textContent = text;\n    feed.prepend(row);\n\n    const children = Array.from(feed.children);\n    if (children.length > 60) {\n      for (let i = 60; i < children.length; i++) children[i].remove();\n    }\n  }\n\n  function dispatchWindowEvent(ev) {\n    try { window.dispatchEvent(new CustomEvent(\"mb.task.event\", { detail: ev })); } catch {}\n  }\n\n  function parseMaybeJSON(raw) {\n    try { return JSON.parse(raw); } catch { return null; }\n  }\n\n  function handleFrame(eventName, rawData) {\n    const data = typeof rawData === \"string\" ? parseMaybeJSON(rawData) : rawData;\n    const ev = (data && typeof data === \"object\") ? data : { kind: eventName, raw: rawData };\n\n      // Phase22 normalization:\n      // server sends event: task.event with payload { type:\"task.created|task.completed|task.failed\", taskId:\"...\" }\n      if (eventName === \"task.event\") {\n        if (!ev.kind && ev.type) ev.kind = ev.type;\n        if (ev.kind === \"task.event\" && ev.type) ev.kind = ev.type;\n        if (ev.task_id == null && ev.taskId != null) ev.task_id = ev.taskId;\n        if (ev.run_id == null && ev.runId != null) ev.run_id = ev.runId;\n      }\n\n    if (!ev.kind) ev.kind = eventName;\n\n    const key = `${eventName}|${ev.kind}|${ev.ts ?? \"\"}|${ev.task_id ?? ev.id ?? \"\"}|${ev.run_id ?? \"\"}|${ev.cursor ?? \"\"}`;\n    if (seen.has(key)) return;\n    seen.add(key);\n\n    if (ev.kind === \"task.created\" || ev.kind === \"task.completed\" || ev.kind === \"task.failed\") {\n      bumpCounts(String(ev.kind));\n    }\n\n    appendLine(formatLine(ev, eventName), String(ev.kind ?? eventName));\n    dispatchWindowEvent(ev);\n  }\n\n  let es = null;\n  let attempt = 0;\n\n  function connect() {\n    ensurePanel();\n\n    if (es) {\n      try { es.close(); } catch {}\n      es = null;\n    }\n\n    const url = SSE_URL;\n    es = new EventSource(url);\n\n    es.onopen = () => {\n      attempt = 0;\n      setDot(\"open\");\n      appendLine(`${new Date().toISOString()}  sse.open  url=${url}`, \"sse.open\");\n      console.log(\"[phase22] task-events SSE open\", url);\n    };\n\n    es.onerror = () => {\n      setDot(\"error\");\n      try { es.close(); } catch {}\n      es = null;\n\n      attempt += 1;\n      const delay = Math.min(15000, 500 * Math.pow(2, Math.min(6, attempt)));\n      appendLine(`${new Date().toISOString()}  sse.error  reconnect_in=${delay}ms`, \"sse.error\");\n      console.log(\"[phase22] task-events SSE error; reconnect in\", delay);\n      setTimeout(connect, delay);\n    };\n\n    es.onmessage = (msg) => handleFrame(\"message\", msg.data);\n\n    const names = [\n      \"hello\",\n      \"heartbeat\",\n      \"task.event\",\n      \"task.created\",\n      \"task.completed\",\n      \"task.failed\",\n      \"task.updated\",\n      \"task.status\",\n    ];\n    for (const name of names) {\n      es.addEventListener(name, (e) => handleFrame(name, e.data));\n    }\n  }\n\n  function boot() {\n    connect();\n    // Guard: if something removes the panel, re-mount + reconnect.\n    setInterval(() => {\n      if (!document.getElementById(PANEL_ID)) {\n        try { connect(); } catch {}\n      }\n    }, 2000);\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", boot, { once: true });\n  } else {\n    boot();\n  }\n\n  window.__MB_TASK_EVENTS = { url: SSE_URL, reconnect: () => connect() };\n})();\n", "(() => {\n  // Phase 22: bind task-events SSE -> Task Delegation + status UI (best-effort)\n\n  const TASK_EVENT_NAME = \"mb.task.event\";\n  const tasks = new Map();\n\n  const STATUS_CLASS = {\n    queued: \"task-status-queued\",\n    done: \"task-status-done\",\n    failed: \"task-status-failed\",\n  };\n\n  function normStatus(s) {\n    const v = String(s ?? \"\").toLowerCase();\n    if (v === \"queued\" || v === \"pending\") return \"queued\";\n    if (v === \"done\" || v === \"complete\" || v === \"completed\") return \"done\";\n    if (v === \"failed\" || v === \"error\") return \"failed\";\n    return v || \"unknown\";\n  }\n\n  function pluckId(ev) {\n    return ev?.task_id ?? ev?.taskId ?? ev?.id ?? ev?.task?.id ?? null;\n  }\n\n  function pluckTask(ev) {\n    const t = ev?.task && typeof ev.task === \"object\" ? ev.task : null;\n    const id = pluckId(ev);\n    const status =\n      ev?.status ??\n      ev?.payload?.status ??\n      t?.status ??\n      (ev?.kind === \"task.created\" ? \"queued\" : null);\n\n    return {\n      id: id != null ? String(id) : null,\n      status: status != null ? normStatus(status) : null,\n      title: t?.title ?? ev?.title ?? null,\n      agent: t?.agent ?? ev?.agent ?? null,\n      error: ev?.error ?? ev?.payload?.error ?? t?.error ?? null,\n      updated_at: t?.updated_at ?? ev?.ts ?? Date.now(),\n    };\n  }\n\n  function setStatusOnNode(node, status) {\n    if (!node) return;\n    const s = normStatus(status);\n    node.setAttribute(\"data-task-status\", s);\n    node.classList?.remove(...Object.values(STATUS_CLASS));\n    if (STATUS_CLASS[s]) node.classList?.add(STATUS_CLASS[s]);\n\n    const sub =\n      node.querySelector?.(\"[data-task-field='status']\") ||\n      node.querySelector?.(\".task-status\") ||\n      node.querySelector?.(\".status\") ||\n      null;\n    if (sub) sub.textContent = s;\n  }\n\n  function updateTaskRowUI(task) {\n    if (!task?.id) return;\n    const id = String(task.id);\n    const nodes = [\n      document.getElementById(`task-${id}`),\n      document.getElementById(`task_${id}`),\n      document.querySelector?.(`[data-task-id=\"${CSS.escape(id)}\"]`),\n      document.querySelector?.(`[data-taskid=\"${CSS.escape(id)}\"]`),\n    ].filter(Boolean);\n\n    for (const n of nodes) setStatusOnNode(n, task.status);\n  }\n\n  function updateCountersUI() {\n    let queued = 0, done = 0, failed = 0;\n    for (const t of tasks.values()) {\n      const s = normStatus(t.status);\n      if (s === \"queued\") queued++;\n      else if (s === \"done\") done++;\n      else if (s === \"failed\") failed++;\n    }\n\n    const map = [\n      [\"queued\", queued],\n      [\"done\", done],\n      [\"failed\", failed],\n    ];\n\n    for (const [k, v] of map) {\n      const el =\n        document.getElementById(`task-count-${k}`) ||\n        document.getElementById(`tasks-${k}-count`) ||\n        document.querySelector?.(`[data-task-count=\"${k}\"]`) ||\n        null;\n      if (el) el.textContent = String(v);\n    }\n  }\n\n  function ingestTask(task) {\n    if (!task?.id) return;\n    const id = String(task.id);\n    const prev = tasks.get(id) || {};\n    const next = { ...prev, ...task, id, status: task.status ?? prev.status };\n    tasks.set(id, next);\n    updateTaskRowUI(next);\n    updateCountersUI();\n  }\n\n  function onTaskEvent(ev) {\n    const t = pluckTask(ev);\n    if (!t.id && ev?.kind) {\n      if (ev.kind === \"task.completed\") t.status = \"done\";\n      if (ev.kind === \"task.failed\") t.status = \"failed\";\n    }\n    if (t.id) ingestTask(t);\n  }\n\n  function attach() {\n    if (window.__PHASE22_TASK_UI_BOUND) return;\n    window.__PHASE22_TASK_UI_BOUND = true;\n\n    window.addEventListener(TASK_EVENT_NAME, (e) => {\n      try { if (window.__UI_DEBUG || window.__PHASE22_DEBUG) if (window.__UI_DEBUG || window.__PHASE22_DEBUG) console.log(\"[phase22] mb.task.event\", e.detail); onTaskEvent(e.detail); } catch {}\n    });\n\n    window.__PHASE22_TASK_UI = { tasks }; console.log(\"[phase22] bindings attached\");\n  }\n\n  if (document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", attach, { once: true });\n  } else {\n    attach();\n  }\n})();\n", "import \"./sse-heartbeat-shim.js\";\nimport \"./heartbeat-stale-indicator.js\";\nimport \"./task-events-sse-listener.js\";\n// Phase 11 \u2013 Unified dashboard bundle entrypoint\n\n// Core dashboard status + tiles\nimport \"./dashboard-status.js\";\n\n// Phase 15/16 boundary: disable optional SSE (OPS + Reflections) until backends exist\nif (typeof window !== \"undefined\" && typeof window.__DISABLE_OPTIONAL_SSE === \"undefined\") {\n  window.__DISABLE_OPTIONAL_SSE = false;\n}\n\nimport \"./agent-status-row.js\";\n\n// OPS / PM2 status + SSE wiring\nimport \"./dashboard-broadcast.js\";\nimport \"./ops-status-widget.js\";\nimport \"./ops-globals-bridge.js\";\nimport \"./ops-pill-state.js\";\nimport \"./dashboard-tasks-widget.js\";\n\n// Matilda chat console wiring\nimport \"./matilda-chat-console.js\";\n\n// TEMP: dashboard graph disabled until canvas is present on all pages\n// import \"./dashboard-graph.js\";\n\n\n// Phase 22: task-events live UI\nimport \"./task-events-sse-client.js\";\nimport \"./phase22_task_delegation_live_bindings.js\";\n"],

Notes:
- Inventory only; no fixes applied.
- Anything listed that assigns lifecycle truth without persisted `task_events` is a Phase25 violation.
- Anything that derives `task_id` from event row ids / DOM ids is a Phase25 violation.

