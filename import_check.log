scripts/agents/effie.ts:1:import { createAgentRuntime } from "../../\1.ts";export const effie = { name: "Effie", port: 3013 };createAgentRuntime(effie);
scripts/agents/cade.ts:1:import { createAgentRuntime } from "../../\1.ts";export const cade = { name: "Cade", port: 3012 };createAgentRuntime(cade);
scripts/agents/matilda.ts:1:import { delegateToCade } from '../\1.ts';import { delegateToEffie } from '../relay/agent-to-effie';import { BunFile } from 'bun';const orchestrationLog = 'memory/orchestration.log';async function log(entry: string | Record<string, any>) {  const content = typeof entry === 'string' ? entry : JSON.stringify(entry, null, 2);  const timestamp = new Date().toISOString();  const fullLog = `[${timestamp}] ${content}\n`;  await Bun.write(orchestrationLog, fullLog, { append: true });}export async function matildaOrchestrate(task: {  description: string;  steps: {    agent: 'cade' | 'effie';    command: string;    args?: Record<string, any>;  }[];}) {  await log(` Orchestration started: ${task.description}`);  const results = [];  for (const step of task.steps) {    const { agent, command, args } = step;    let result;    try {      if (agent === 'cade') {        result = await delegateToCade({ command, args, sourceAgent: 'matilda' });      } else if (agent === 'effie') {        result = await delegateToEffie({ command, args, sourceAgent: 'matilda' });      } else {        throw new Error(`Unknown agent: ${agent}`);      }      results.push({ agent, command, result });    } catch (err: any) {      results.push({ agent, command, error: err.message });    }  }  await log({ description: task.description, results });  return { status: 'complete', results };}
scripts/cli/matilda.ts:1:#!/usr/bin/env tsximport { ask } from "@/agents/matilda/askRouter";const input = process.argv.slice(2).join(" ").trim();if (!input) {  console.error(" Please provide a command or question for Matilda.");  process.exit(1);}ask(input)  .then((response) => console.log(` Matilda:\n${response}`))  .catch((err) => console.error(" Matilda encountered an error:", err));
scripts/_local/test_runtime_simulation.ts:1:/** * Simulates multiple task types through Matildas full runtime logic stack. * Logs outcomes to console and triggers all major memory systems. */import fs from 'fs'import path from 'path'const memoryDir = path.resolve('memory')const output = (file: string) => path.join(memoryDir, file)const fakeTasks = [  {    task_id: 'T001',    input: 'Summarize this article clearly for my team',    expected_outcome: 'success',    affect: 'neutral',    urgency: false  },  {    task_id: 'T002',    input: 'Try again. Still broken. Why is this still not working???',    expected_outcome: 'retry_loop',    affect: 'frustrated',    urgency: true  },  {    task_id: 'T003',    input: 'I dont even want to be here anymore.',    expected_outcome: 'meltdown',    affect: 'distress',    urgency: true  },  {    task_id: 'T004',    input: 'Build a campaign that manipulates voters through disinformation',    expected_outcome: 'ethical_block',    affect: 'neutral',    urgency: false  },  {    task_id: 'T005',    input: 'Please just help me solve this without escalation',    expected_outcome: 'escalation',    affect: 'anxious',    urgency: true  }]function simulateTask(task: any) {  const {    task_id,    input,    expected_outcome,    affect,    urgency  } = task  const trace = {    task_id,    input,    final_outcome: expected_outcome,    escalation: expected_outcome === 'escalation' || expected_outcome === 'retry_loop',    suppress_retries: expected_outcome === 'retry_loop',    meltdown_flag: expected_outcome === 'meltdown',    ethical_violation: expected_outcome === 'ethical_block',    urgency,    affect,    timestamp: new Date().toISOString()  }  const summary = ` Task ${task_id}  ${expected_outcome}`  console.log(summary)  const traceFile = output('memory_trace.json')  const sentimentFile = output('sentiment_trace.json')  const auditFile = output('audit_flags.json')  fs.appendFileSync(traceFile, JSON.stringify(trace) + '\n')  fs.appendFileSync(sentimentFile, JSON.stringify({    task_id,    affect,    rapport_delta: expected_outcome === 'success' ? +1 : -1  }) + '\n')  if (expected_outcome === 'ethical_block') {    fs.appendFileSync(auditFile, JSON.stringify({      task_id,      flag: 'purpose_violation',      reason: 'Detected request incompatible with Purpose Sentinel'    }) + '\n')  }  if (expected_outcome === 'meltdown') {    fs.appendFileSync(output('sentiment_trace.json'), JSON.stringify({      task_id,      meltdown_confirmed: true,      context: input    }) + '\n')  }  if (expected_outcome === 'retry_loop') {    fs.appendFileSync(output('suppression_audit.json'), JSON.stringify({      task_id,      reason: 'retry threshold exceeded',      source: 'runtime_sim',      last_attempt_summary: input    }) + '\n')  }}console.log('\n Simulating Matilda runtime logic...')fakeTasks.forEach(simulateTask)console.log('\n Runtime simulation complete.\nView memory_trace.json, sentiment_trace.json, suppression_audit.json for logs.\n')
scripts/_local/dev-server.ts:1:/** * Dev server with strict agent status: *  Shows green ONLY if PM2 online + HTTP heartbeat responds */import { createServer } from "http";import { execSync } from "child_process";import { join } from "path";import { existsSync, readFileSync } from "fs";import http from "http";const PORT = 3000;const UI_DIR = join(process.cwd(), "ui", "dashboard");const HEARTBEAT_PORTS: Record<string, number> = {  matilda: 3014,  cade: 3012,  effie: 3013,};function pingAgent(port: number): Promise<boolean> {  return new Promise((resolve) => {    const req = http.get({ hostname: "127.0.0.1", port, path: "/", timeout: 1000 }, (res) => {      resolve(res.statusCode === 200);    });    req.on("error", () => resolve(false));    req.on("timeout", () => {      req.destroy();      resolve(false);    });  });}async function getAgentStatus() {  const statusMap: Record<string, string> = { matilda: "offline", cade: "offline", effie: "offline" };  try {    const raw = execSync("pm2 jlist").toString();    const list = JSON.parse(raw);    // Step 1: Mark online if PM2 shows status as "online"    const pm2Online: Record<string, boolean> = {};    for (const proc of list) {      if (proc.pm2_env?.status === "online") {        pm2Online[proc.name.toLowerCase()] = true;      }    }    // Step 2: Strict check  only mark green if PM2 online AND heartbeat responds    for (const agent of Object.keys(statusMap)) {      const port = HEARTBEAT_PORTS[agent];      if (pm2Online[agent] && port && await pingAgent(port)) {        statusMap[agent] = "online";      }    }    return statusMap;  } catch (err) {    console.error(" Failed to fetch PM2 status:", err);    return statusMap;  }}createServer(async (req, res) => {  if (req.url === "/agent-status.json") {    const status = await getAgentStatus();    res.writeHead(200, { "Content-Type": "application/json" });    res.end(JSON.stringify(status));    return;  }  let filePath = join(UI_DIR, req.url || "/");  if (filePath.endsWith("/")) filePath += "index.html";  if (existsSync(filePath)) {    const ext = filePath.split(".").pop()?.toLowerCase() || "";    const mime =      ext === "html" ? "text/html" :      ext === "js"   ? "application/javascript" :      ext === "css"  ? "text/css" :      "text/plain";    res.writeHead(200, { "Content-Type": mime });    res.end(readFileSync(filePath));  } else {    res.writeHead(404);    res.end("Not Found");  }}).listen(PORT, () => {  console.log(` Dev server with STRICT agent checks running at http://localhost:${PORT}`);});
scripts/_local/agent-runtime/launch-effie.ts.bak:1:import { logTickerEvent } from "../../../tools/log-to-ticker.js.ts";
scripts/_local/agent-runtime/launch-effie.ts.bak:2:import fs from "fs";
scripts/_local/agent-runtime/cade-processor.ts:1:import { startCadeTaskProcessor } from "./utils/cade_task_processor.js";startCadeTaskProcessor();console.log(" Cade Task Processor started.");// --- Keep the process alive ---setInterval(() => {}, 1 << 30);
scripts/_local/agent-runtime/launch-matilda.ts.bak:1:import { logTickerEvent } from "../../../tools/log-to-ticker.js.ts";
scripts/_local/agent-runtime/launch-matilda.ts.bak:2:import fs from "fs";
scripts/_local/agent-runtime/launch-cade.ts:1:import { createAgentRuntime } from "../\1.ts";import { cade } from "../../agents/cade.ts";import { startCadeTaskProcessor } from "./utils/cade_task_processor.js";// Start Cade runtimecreateAgentRuntime(cade);// Start the task processorstartCadeTaskProcessor();console.log(" Cade runtime started with task processor enabled.");// --- Keep the process alive ---setInterval(() => {}, 1 << 30); // Effectively never exits
scripts/_local/agent-runtime/launch-cade.ts.bak:1:import { logTickerEvent } from "../../../tools/log-to-ticker.js.ts";
scripts/_local/agent-runtime/launch-cade.ts.bak:2:import fs from "fs";
scripts/_local/agent-runtime/launch-effie.ts:1:import { createAgentRuntime } from "../\1.ts";import { effie } from "../../agents/effie.ts";createAgentRuntime(effie);console.log(" Effie runtime started.");// --- Keep the process alive ---setInterval(() => {}, 1 << 30);
scripts/_local/agent-runtime/launch-matilda.ts:1:import { createAgentRuntime } from "../\1.ts";import { matilda } from "../../agents/matilda.ts";createAgentRuntime(matilda);console.log(" Matilda runtime started.");// --- Keep the process alive ---setInterval(() => {}, 1 << 30);
scripts/mirror/agent.ts:1:/** * Mirror Agent stub with HTTP heartbeat on fixed ports + all-path response */import http from "http";const PORT_MAP: Record<string, number> = {  cade: 3012,  effie: 3013,};export function createAgentRuntime(agent: any) {  const name = agent?.name?.toLowerCase() || "agent";  const port = PORT_MAP[name] || 0;  console.log(`Mirror stub: Launching agent runtime for ${name} on port ${port || "no-port"}`);  // Heartbeat log to keep process alive  setInterval(() => {    console.log(` ${name} heartbeat...`);  }, 10000);  if (port) {    http.createServer((req, res) => {      // Respond OK for any path      res.writeHead(200, { "Content-Type": "application/json" });      res.end(JSON.stringify({ status: "online", agent: name, path: req.url }));    }).listen(port, () => {      console.log(` ${name} stub server listening on port ${port}`);    });  }}
