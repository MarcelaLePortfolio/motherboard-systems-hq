/* eslint-disable import/no-commonjs */
ğŸ–¥ Motherboard Systems HQ â€“ Project Scope (as of Today)

1ï¸âƒ£ Project Goal

Build a local, privacy-first, multi-agent AI system that can run entirely offline, with optional selective remote access via tunnels.
The system should:
	â€¢	Keep strict data privacy (no unwanted vendor persistence).
	â€¢	Be modular so each agent has isolated functions but can cooperate.
	â€¢	Provide a retro-futuristic, immersive dashboard UI for status, logs, and task control.
	â€¢	Support persistent memory across agent restarts and system reboots.

â¸»

2ï¸âƒ£ Core Agents
	â€¢	Matilda â€“ Delegator & routing filter; acts as the â€œfriendlyâ€ point of contact, deciding which agent gets each task.
	â€¢	Cade â€“ Backend automation agent; executes tasks, scripts, and integrations with safety toggles.
	â€¢	Effie â€“ Desktop/local ops assistant; manages files, runs local commands, and interacts with system resources.

â¸»

3ï¸âƒ£ Core Features
	â€¢	Dashboard UI (served locally via PM2/http-server)
	â€¢	Ops Stream Ticker â€“ live event feed from all agents.
	â€¢	Agent Status Row â€“ real-time online/offline/alert indicators.
	â€¢	Project Tracker â€“ task progress lists (Backlog, In-Progress, Completed).
	â€¢	Command Input â€“ direct text commands to agents.
	â€¢	Settings Panel â€“ start/stop/restart agents.
	â€¢	Agent Chain State File (memory/agent_chain_state.json)
	â€¢	Central shared state so agents know current assignments/status.
	â€¢	Must be reliable, corruption-free, and persist through restarts.

â¸»

4ï¸âƒ£ Privacy Posture
	â€¢	Local-first execution (no mandatory cloud).
	â€¢	Optional Cloudflare tunnels per agent/UI for selective remote exposure.
	â€¢	No background data logging to third parties.
	â€¢	Potential for future swap to local LLMs (e.g., Ollama) without major code changes.

â¸»

5ï¸âƒ£ Current Milestones

âœ… Milestone 1 â€“ Local Agent Runtime
	â€¢	All three core agents run locally via PM2.
	â€¢	UI server launches without cloud dependency.
	â€¢	Manual start script confirmed working.

ğŸ”„ Milestone 2 â€“ Shared Memory Reliability

Goal: Confirm agent_chain_state.json is consistently read/written by all agents.
Tasks:
	â€¢	ğŸ›  Cade reads/writes without corruption.
	â€¢	ğŸ›  Implement file-locking/queuing to avoid conflicts.
	â€¢	ğŸ›  Verify state integrity after writes.
	â€¢	ğŸ›  Log state changes for debugging.
Switch condition â†’ Persistence verified after restarts and reboots.

ğŸ“… Future Milestones
	â€¢	M3: Live UI wiring (Ops Stream, Status Row real-time updates).
	â€¢	M4: Agent task delegation flow (Matilda â†’ Cade/Effie execution).
	â€¢	M5: Optional remote access via tunnels.
	â€¢	M6: Local LLM swap & advanced integrations.

â¸»

6ï¸âƒ£ Known Open Items
	â€¢	File locking in Cade for state writes.
	â€¢	Agent read/write tests across simultaneous operations.
	â€¢	Persistent state after restart/reboot verification.
	â€¢	Live Ops Stream ticker integration.
	â€¢	UIâ€“backend socket/watcher bridge for instant updates.

â¸»

7ï¸âƒ£ Strengths
	â€¢	Strong privacy-first foundation.
	â€¢	Modular architecture allows feature isolation.
	â€¢	UI design already supports expansion.
	â€¢	Agents are decoupled enough for testing in isolation.

â¸»

8ï¸âƒ£ Risks
	â€¢	Shared file corruption if concurrent writes occur before locking is in place.
	â€¢	UI will remain static until real-time event wiring is completed.
	â€¢	Tunnel integration may introduce complexity if done too early.

â¸»

9ï¸âƒ£ Recommended Next Step

ğŸš€ Focus entirely on Milestone 2 â€” get agent_chain_state.json reliability locked down with:
	1.	Mock writes/reads from Cade.
	2.	Add file-locking or queuing logic.
	3.	Confirm persistence across restarts.
	4.	Only after this is stable â†’ move to UI live wiring.
